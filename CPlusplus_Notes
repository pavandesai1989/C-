Dynamic memory allocation geeks
Syntax to use new operator: To allocate memory of any data type, the syntax is:
pointer-variable = new data-type;
Here, pointer-variable is the pointer of type data-type. Data-type could be any built-in data type including array or any user defined data types including structure and class.
Example:
// Pointer initialized with NULL
// Then request memory for the variable
int *p = NULL; 
p = new int;   
 
            OR
 
// Combine declaration of pointer 
// and their assignment
int *p = new int; 
 
Initialize memory: We can also initialize the memory using new operator:
pointer-variable = new data-type(value);
Example:
int *p = new int(25);
float *q = new float(75.25);
Allocate block of memory: new operator is also used to allocate a block(an array) of memory of type data-type.
pointer-variable = new data-type[size];
where size(a variable) specifies the number of elements in an array.
Example:
        int *p = new int[10]
Dynamically allocates memory for 10 integers continuously of type int and returns pointer to the first element of the sequence, which is assigned to p(a pointer). p[0] refers to first element, p[1] refers to second element and so on.
What if enough memory is not available during runtime?
If enough memory is not available in the heap to allocate, the new request indicates failure by throwing an exception of type std::bad_alloc and new operator returns a pointer. Therefore, it may be good idea to check for the pointer variable produced by new before using it program.
 
delete operator geeks
 
// C++ program to illustrate dynamic allocation
// and deallocation of memory using new and delete
#include <iostream>
using namespace std;
 
int main ()
{
    // Pointer initialization to null
    int* p = NULL;
 
    // Request memory for the variable
    // using new operator
    p = new int;
    if (!p)
        cout << "allocation of memory failed\n";
    else
    {
        // Store value at allocated address
        *p = 29;
        cout << "Value of p: " << *p << endl;
    }
 
    // Request block of memory
    // using new operator
    float *r = new float(75.25);
 
    cout << "Value of r: " << *r << endl;
 
    // Request block of memory of size n
    int n = 5;
    int *q = new int[n];
 
    if (!p)
        cout << "allocation of memory failed\n";
    else
    {
        for (int i = 0; i < n; i++)
            q[i] = i+1;
 
        cout << "Value store in block of memory: ";
        for (int i = 0; i < n; i++)
            cout << q[i] << " ";
    }
 
    // freed the allocated memory
    delete p;
    delete r;
 
    // freed the block of allocated memory
    delete[] q;
 
    return 0;
}
 
To free the dynamically allocated array pointed by pointer-variable, use following form of delete:
// Release block of memory 
// pointed by pointer-variable
delete[] pointer-variable;  
 
Example:
   // It will free the entire array
   // pointed by p.
   delete[] p;
#include<iostream>
#include<conio.h>

using namespace std;


void main()
{

	int *p = new int(100);

	delete p;

	double *ptr = new double[10];

	delete []ptr;
}
 
int *ptr = NULL;      //no effect 
delete ptr;  
 
Is it fine to call delete twice for a pointer?
#include<iostream>
using namespace std;
 
int main()
{
    int *ptr = new int;
    delete ptr;
    delete ptr;
    return 0;
}                         //assertion run time error

malloc() vs new
Following are the differences between malloc() and operator new.:
Calling Constructors: new calls constructors, while malloc() does not. In fact primitive data types (char, int, float.. etc) can also be initialized with new. For example, below program prints 10.
#include<iostream>
 
using namespace std;
 
int main()
{
   int *n = new int(10); // initialization with new()
   cout << *n;
   getchar();
   return 0;
}

operator vs function: new is an operator, while malloc() is a function.
return type: new returns exact data type, while malloc() returns void *.
Failure Condition: On failure, malloc() returns NULL where as new Throws.
Memory: In case of new, memory is allocated from free store where as in malloc() memory allocation is done from heap.
Overriding: We are allowed to override new operator where as we can not override the malloc() function legally.
Size: Required size of memory is calculated by compiler for new, where as we have to manually calculate size for malloc().
#include<stdio.h>
#include<stdlib.h>
int main()
{
    int x;
    int *ptr1 = &x;
    int *ptr2 = (int *)malloc(sizeof(int));
    int *ptr3 = new int;
    int *ptr4 = NULL;
 
    /* delete Should NOT be used like below because x is allocated 
        on stack frame */
    delete ptr1;  
 
    /* delete Should NOT be used like below because x is allocated 
        using malloc() */
    delete ptr2;  
 
    /* Correct uses of delete */
    delete ptr3;
    delete ptr4;
 
    getchar();
    return 0;
}
 
#include<iostream>
using namespace std;
 
int main()
{
    int *ptr = new int;
    delete ptr;    //frees memory pointed by ptr but ptr will contain adress so make it NULL

	ptr = NULL;  //else ptr will be angling 
}

Can a C++ class have an object of self type?
A class declaration can contain static object of self type, it can also have pointer to self type, but it cannot have a non-static object of self type.
For example, following program works fine.
// A class can have a static member of self type
#include<iostream>
 
using namespace std;
 
class Test {
  static Test self;  // works fine
 
  /* other stuff in class*/
 
};
 
int main()
{
  Test t;
  getchar();
  return 0;
}

Run on IDE
And following program also works fine.
// A class can have a pointer to self type
#include<iostream>
 
using namespace std;
 
class Test {
  Test * self; //works fine
 
  /* other stuff in class*/
 
};
 
int main()
{
  Test t;
  getchar();
  return 0;
}

Run on IDE
But following program generates compilation error “field `self’ has incomplete type”
// A class cannot have non-static object(s) of self type.
#include<iostream>
 
using namespace std;
 
class Test {
  Test self; // Error
 
  /* other stuff in class*/
 
};
 
int main()
{
  Test t;
  getchar();
  return 0;
}

Run on IDE
If a non-static object is member then declaration of class is incomplete and compiler has no way to find out size of the objects of the class.
Static variables do not contribute to the size of objects. So no problem in calculating size with static variables of self type.
For a compiler, all pointers have a fixed size irrespective of the data type they are pointing to, so no problem with this also.

Size of an empty class is not zero. It is 1 byte generally. It is nonzero to ensure that the two different objects will have different addresses.
 
#include<iostream>
using namespace std;
 
class Empty { };
 
class Derived: Empty { int a; };
 
int main()
{
    cout << sizeof(Derived);
    return 0;
}
Note that the output is not greater than 4. There is an interesting rule that says that an empty base class need not be represented by a separate byte.
 
 
Can static functions be virtual in C++?
No, because it doesn't make any sense in C++.
Virtual functions are invoked when you have a pointer/reference to an instance of a class. Static functions aren't tied to a particular instance, they're tied to a class. C++ doesn't have pointers-to-class, so there is no scenario in which you could invoke a static function virtually.
 
The point of virtual member functions is that they are dispatched based on the dynamic type of the object instance on which they are called. On the other hand, static functions are not related to any instances and are rather a property of the class. Thus it makes no sense for them to be virtual. If you must, you can use a non-static dispatcher:
 
Why static member function cannot be const and volatile.?
The reason for this is that a const (or volatile or virtual) static method wouldn't make sense (in the traditional sense, see below). For example, const implies you can't modify the object's members, but in the case of statics, there's no object to talk about.
 
What does volatile man in c++?However, sometimes, optimization (of some parts of your program) may be undesirable, because it may be that someone else is changing the value of some_int from outside the program which compiler is not aware of, since it can't see it; but it's how you've designed it. In that case, compiler's optimization would not produce the desired result!
Hey compiler, I'm volatile and, you know, I can be changed by some XYZ that you're not even aware of. That XYZ could be anything. Maybe some alien outside this planet called program. Maybe some lighting, some form of interrupt, volcanoes, etc can mutate me. Maybe. You never know who is going to change me! So O you ignorant, stop playing an all-knowing god, and don't dare touch the code where I'm present. Okay?
 
Generally speaking, the volatile keyword is intended to prevent the (pseudo)compiler from applying any optimizations on the code that assume values of variables cannot change "on their own." (c) Wikipedia
Local Classes in C++
A class declared inside a function becomes local to that function and is called Local Class in C++. For example, in the following program, Test is a local class in fun().
#include<iostream>
using namespace std;
 
void fun()  
{
      class Test  // local to fun
      {
        /* members of Test class */
      };
}
 
int main()
{
    return 0;
}

Run on IDE


Following are some interesting facts about local classes.
1) A local class type name can only be used in the enclosing function. For example, in the following program, declarations of t and tp are valid in fun(), but invalid in main().
#include<iostream>
using namespace std;
 
void fun()  
{       
      // Local class 
      class Test  
      {
        /* ... */     
      };
 
      Test t;  // Fine
      Test *tp;  // Fine
}
 
int main()
{
    Test t;  // Error
    Test *tp;  // Error
    return 0;
}

Run on IDE


2) All the methods of Local classes must be defined inside the class only. For example, program 1 works fine and program 2 fails in compilation.
// PROGRAM 1
#include<iostream>
using namespace std;
 
void fun()  
{
    class Test  // local to fun
    {
    public:
   
       // Fine as the method is defined inside the local class   
       void method() {
          cout << "Local Class method() called";
       }
    };      
 
    Test t;
    t.method();  
}
 
int main()
{
    fun();
    return 0;
}

Run on IDE
Output:
Local Class method() called
// PROGRAM 2
#include<iostream>
using namespace std;
 
void fun()
{
    class Test  // local to fun
    {
    public:
        void method();
    };
     
    // Error as the method is defined outside the local class
    void Test::method()
    {
        cout << "Local Class method()";
    }
}
 
int main()
{
    return 0;
}

Run on IDE
Output:
Compiler Error:
 In function 'void fun()':
 error: a function-definition is not allowed here before '{' token


3) A Local class cannot contain static data members. It may contain static functions though. For example, program 1 fails in compilation, but program 2 works fine.
// PROGRAM 1
#include<iostream>
using namespace std;
 
void fun()  
{
      class Test  // local to fun
      {
         static int i;
      };
}
 
int main()
{
    return 0;
}

Run on IDE
Compiler Error:
 In function 'void fun()':
 error: local class 'class fun()::Test' shall not have static data member 'int fun()::Test::i'
// PROGRAM 2
#include<iostream>
using namespace std;
 
void fun()
{
    class Test  // local to fun
    {
    public:
        static void method()
        {
            cout << "Local Class method() called";
        }
    };
 
    Test::method();
}
 
int main()
{
    fun();
    return 0;
}

Run on IDE
Output:
Local Class method() called


4) Member methods of local class can only access static and enum variables of the enclosing function. Non-static variables of the enclosing function are not accessible inside local classes.For example, the program 1 compiles and runs fine. But, program 2 fails in compilation.
// PROGRAM 1
#include<iostream>
using namespace std;
 
void fun()  
{
      static int x;
      enum {i = 1, j = 2};
 
      // Local class
      class Test
      {
        public:
          void method() {
              cout << "x = " << x << endl;   // fine as x is static
              cout << "i = " << i << endl;   // fine as i is enum
          }
      };
 
      Test t;
      t.method();
}
 
int main()
{
    fun();
    return 0;
}

Run on IDE
Output:
x = 0
i = 1
// PROGRAM 2
#include<iostream>
using namespace std;
 
void fun()  
{
      int x;
 
      // Local class
      class Test
      {
        public:
          void method() {
              cout << "x = " << x << endl;
          }
      };
 
      Test t;
      t.method();
}
 
int main()
{
    fun();
    return 0;
}

Run on IDE
Output:
  In member function 'void fun()::Test::method()':
  error: use of 'auto' variable from containing function


5) Local classes can access global types, variables and functions. Also, local classes can access other local classes of same function.. For example, following program works fine.
#include<iostream>
using namespace std;
 
int x;
 
void fun()  
{
 
      // First Local class
      class Test1 {
      public:
         Test1() { cout << "Test1::Test1()" << endl; }
      };
 
      // Second Local class
      class Test2
      {
           // Fine: A local class can use other local classes of same function
           Test1 t1;
      public:
          void method() {
              // Fine: Local class member methods can access global variables.
              cout << "x = " << x << endl;
          }
      };
 
      Test2 t;
      t.method();
}
 
int main()
{
    fun();
    return 0;
}

Run on IDE
Output:
Test1::Test1()
x = 0
why local class cannot contain static data members
 Normal static datamembers are disallowed because there is no way to define them after being declared.
Also dont forget you can create a local const variable outside the.class that you can use inside the class as long as you only read its value (that is, as long as you dont take.its.address).
Sorry for being a slacker and just throwing out stuff :) To be a little more precise. Static members of a class need to be defined in global scope, e.g.
foo.h
class A {
  static int dude;
};
foo.cpp
int A::dude = 314;
Now, since the scope inside void foo(int x) is not global, there is no scope to define the static member. Hope this was a bit clearer.
Vvvvvvvvvvvvvvvvvimp
#include<iostream>
#include<conio.h>

using namespace std;


class X
{
public:
	int a;
};



void main()
{
	X ob;

	cout<<ob.a<<endl;
}                   //run time error a being used without initlisation

If you need a copy constructor, it's because you need something like a deep copy, or some other management of resources. Thus is is almost certain that you will need a destructor and override the assignment operator.


In C++, We can have more than one constructor in a class with same name, as long as each has a different list of arguments.This concept is known as Constructor Overloading and is quite similar to function overloading.

INITIALISATION:vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvimp
#include<iostream>
 
using namespace std;
 
class Test {
  private:    
    int y;
    int x;    
  public:
    Test() : x(10), y(x + 10) {}
    void print();
};
 
void Test::print()
{ 
   cout<<"x = "<<x<<" y = "<<y; 
}
 
int main()
{
    Test t;
    t.print();
    getchar();
    return 0;               //x=10  and y is garbage 
}
because y is initialized before x as it appears before in the class declaration.
SOLUTION:
class Test {
  private: 
  int x;  
  int y;
  public:
    Test() : x(10), y(x + 10) {}
    void print();
};

PRIVATE DESTRUCTOR:
We noticed in the above programs, when a class has private destructur, only dynamic objects of that class can be created.
#include <iostream>
 
// A class with private destuctor
class Test
{
private:
    ~Test() {}
friend void destructTest(Test* );
};
 
// Only this function can destruct objects of Test
void destructTest(Test* ptr)
{
    delete ptr;
}
 
int main()
{
    // create an object
    Test *ptr = new Test;
 
    // destruct the object
    destructTest (ptr);
 
    return 0;
}
Playing with Destructors in C++
#include <iostream>
using namespace std;
 
int i;
 
class A
{
public:
    ~A()
    {
        i=10;
    }
};
 
int foo()
{
    i=3;
    A ob;
    return i;
}
 
int main()
{
    cout << "i = " << foo() << endl;
    return 0;
}
How to make output 10 of above pgm?
int& foo()
{
    i = 3;
    A ob;
    return i;
}
 
Or crate ob in block scope
 
Can we make a class constructor virtual in C++ to create polymorphic objects? No. C++ being static typed (the purpose of RTTI is different) language, it is meaningless to the C++ compiler to create an object polymorphically. The compiler must be aware of the class type to create the object. In other words, what type of object to be created is a compile time decision from C++ compiler perspective
Encapsulation in C++
In normal terms Encapsulation is defined as wrapping up of data and information under a single unit. In Object Oriented Programming, Encapsulation is defined as binding together the data and the functions that manipulates them.
 
// c++ program to explain
// Encapsulation
 
#include<iostream>
using namespace std;
 
class Encapsulation
{
    private:
        // data hidden from outside world
        int x;
         
    public:
        // function to set value of 
        // variable x
        void set(int a)
        {
            x =a;
        }
         
        // function to return value of
        // variable x
        int get()
        {
            return x;
        }
};
 
// main function
int main()
{
    Encapsulation obj;
     
    obj.set(5);
     
    cout<<obj.get();
    return 0;
}
 In the above program the variable x is made private. This variable can be accessed and manipulated only using the functions get() and set() which are present inside the class. Thus we can say that here, the variable x and the functions get() and set() are binded together which is nothing but encapsulation. 
 
As we have seen in above example, access specifiers plays an important role in implementing encapsulation in C++. The process of implementing encapsulation can be sub-divided into two steps:
The data members should be labeled as private using the private access specifiers
The member function which manipulates the data members should be labeled as public using the public access specifier
 
 
“delete this” in C++ vvvvvvvvvvvimp
delete operator works only for objects allocated using operator new (See http://www.geeksforgeeks.org/?p=8539). If the object is created using new, then we can do delete this, otherwise behavior is undefined.
class A
{
  public:
    void fun()
    {
        delete this;
    }
};
 
int main()
{
  /* Following is Valid */
  A *ptr = new A;
  ptr->fun();
  ptr = nullptr;// make ptr NULL to make sure that things are not accessed using ptr. 
 
 
  /* And following is Invalid: Undefined Behavior */
  A a;
  a.fun();
 
 
  return 0;
}

Once delete this is done, any member of the deleted object should not be accessed after deletion.
#include<iostream>
using namespace std;
 
class A
{
  int x;
  public:
    A() { x = 0;}
    void fun() {
      delete this;
 
      /* Invalid: Undefined Behavior */
      cout<<x;
    }
};


 
 
 
To return reference to calling object we use this pointer
 
2) To return reference to the calling object
/* Reference to the calling object can be returned */
Test& Test::func ()
{
   // Some processing
   return *this;
} 

 
 
This pointer cannot be changed 
#include<iostream>
using namespace std;
 
class Test
{
private:
  int x;
public:
  Test(int x = 0) { this->x = x; }
  void change(Test *t) { this = t; }            //error this is constant 
  void print() { cout << "x = " << x << endl; }
};
 
int main()
{
  Test obj(5);
  Test *ptr = new Test (10);
  obj.change(ptr);
  obj.print();
  return 0;
}

Static members don’t have this pointer
#include<iostream>
using namespace std;
 
class Test
{
private:
  int x;
  int y;
public:
  Test(int x = 0, int y = 0) { this->x = x; this->y = y; }
  static void fun1() { cout << "Inside fun1()"; }
  static void fun2() { cout << "Inside fun2()"; this->fun1(); }  //error this only for nonstatic
};
 
int main()
{
  Test obj;
  obj.fun2();
  return 0;
}

 
 
Can references refer to invalid location in C++?
1) Reference to value at uninitialized pointer.
int *ptr;
int &ref = *ptr;  // Reference to value at some random memory location

RUN TIME ERROR
2) Reference to a local variable is returned.
int& fun()
{
   int a = 10;
   return a;
}

Once fun() returns, the space allocated to it on stack frame will be taken back. So the reference to a local variable will not be valid.
 
 
ARRAYS
Array declaration:
In C, we can declare an array by specifying its and size or by initializing it or by both.
// Array declaration by specifying size
int arr[10];

Run on IDE
// Array declaration by initializing elements 
int arr[] = {10, 20, 30, 40}
 
// Compiler creates an array of size 4. 
// above is same as  "int arr[4] = {10, 20, 30, 40}"

Run on IDE
// Array declaration by specifying size and initializing 
// elements 
int arr[6] = {10, 20, 30, 40}
 
// Compiler creates an array of size 6, initializes first 
// 4 elements as specified by user and rest two elements as 0.
// above is same as  "int arr[] = {10, 20, 30, 40, 0, 0}"

 
#include <iostream>

using namespace std;


//Accessing array elements using base address

int main()
{
	int arr[5] = {1,2,3,4,5};

	//int *ptr = arr;

	for(int i=0;i<5;i++)
		cout<<*(arr+i)<<endl;	 //array name gives base address of array

}

#include <iostream>

using namespace std;


//Accessing array elements using pointer to array

int main()
{
	int arr[5] = {1,2,3,4,5};

	int *ptr = arr;

	for(int i=0;i<5;i++)
		cout<<*(ptr+i)<<endl;
}
#include <iostream>

using namespace std;


//accepting and displayig data

int main()
{
	int arr[5] ;

cout<<"enter the elements"<<endl;

for(int i=0;i<5;i++)
	cin>>arr[i];

cout<<"elements are"<<endl;

for(int i=0;i<5;i++)
	cout<<arr[i]<<endl;

}

Vvvvvvvvvvvvvvvvimp

#include <iostream>

using namespace std;

//accepting and displayig data

void Pass(int arr[])
{
	arr[0] = 10;
	arr[1] = 20;
	arr[2] = 30;
}
int main()
{
	int arr[5] = {1,2,3};

	cout<<"before"<<'\t'<<arr[0]<<'\t'<<arr[1]<<'\t'<<arr[2]<<endl;     //output is 1 2 3

	Pass(arr);

	cout<<"after"<<'\t'<<arr[0]<<'\t'<<arr[1]<<'\t'<<arr[2]<<endl;     //output is 10 20 30

}

However, because the parameter array in function passArray() is the actual array, passArray() is able to directly change the value of the elements!
TO avoid above 
As a side note, if you want to ensure a function does not modify the array elements passed into it, you can make the array const:

void Pass(const int arr[])
{
	arr[0] = 10;  //compilation error
	arr[1] = 20;
	arr[2] = 30;
}

#include <iostream>

using namespace std;
#define SIZE 100

//Find largest element in array

int main()
{
	int a[SIZE],n,Big;

	cout<<"enter number of elements"<<endl;
	cin>>n;

	cout<<"enter the elements"<<endl;
	
	for(int i=0;i<n;i++)
		cin>>a[i];

	cout<<"elements are"<<endl;
	for(int i=0;i<n;i++)
		cout<<a[i]<<endl;

	Big = a[0];

	for(int i=1;i<n;i++)
	{
		if(a[i]>Big)
			Big = a[i];
	}

	cout<<"large element is"<<Big<<endl;

}

#include<iostream>
using namespace std;
 
int main()
{
   int *ptr = NULL;
   int &ref = *ptr;
   cout << ref;              //exception
}
 
 
 
 
Overloading New and Delete operator in c++
doooooooooooooooooooo
 
 
STL IN C++
Vector:Dynamic array
#include<iostream>
#include<conio.h>
#include<vector>    //include header for vector
using namespace std;


void main()
{
	vector<int> v1;  //blank vector

	vector<char>v2(5); // 5 elements to store char

	vector<int>v3(5,10);  //creates 5 blocks in each block stores value 10
}
 
 
Exception handling:
#include<iostream>
#include<conio.h>

using namespace std;

void main()
{
	int a,b;
	double c;

	try
	{
		cout<<"enter the a "<<endl;
		cin>>a;

		cout<<"enter the b"<<endl;
			cin>>b;

		if(b==0) throw 0;   0 is integer so catch must take integer.Remaining code wont be executed it gives message

		c=(a/b);

		cout<<"value is"<<c<<endl;
	}

	catch(int)
	{
		cout<<"Devide by zero"<<endl;
	}
}
 
 
Friend Function:
Friend function cannot access class data directly .It can use object and dot opeartor.
Majorly used in operator overloading concept.
#include<iostream>
#include<conio.h>

using namespace std;

class Sample
{
private:
	int a,b;
public:
	void SetData(int m,int n);
	friend int Add(Sample ob);
};

void Sample::SetData(int m,int n)
{
	a = m;
	b = n;
}

int Add(Sample ob)
{
	return (ob.a+ob.b);
}


void main()
{
	Sample s;
	int sum;

	s.SetData(10,20);

	sum = Add(s);
}


Add 2 complex numbers using friend class

#include<iostream>
#include<conio.h>

using namespace std;

class Complex
{
private:
	double r,i;

public:
	void Input();
	void Display();
	friend Complex Add(Complex ob1,Complex ob2);
};


void Complex::Input()
{
	cout<<"enter the real part"<<endl;
	cin>>r;

	cout<<"enter the imag part"<<endl;
	cin>>i;
}

void Complex::Display()
{
	cout<<"number is"<<endl;
	cout<<r<<"+"<<"i"<<i<<endl;
}

Complex Add(Complex ob1,Complex ob2)
{
	Complex temp;

	temp.r= ob1.r + ob2.r;
	temp.i= ob1.i + ob2.i;

	return temp;
}



void main()
{
	Complex ob1,ob2,ob3;

	ob1.Input();

	ob2.Input();

	ob1.Display();

	ob2.Display();

	ob3 = Add(ob1,ob2);

	ob3.Display();
}

USING FRIEND FUNCTION IN MORE THAN ONE CLASS’

#include<iostream>
#include<conio.h>

using namespace std;

class Test2;    //forward declaration
class Test1
{
private:
	int a;

public:
	void Geta()
	{
		cout<<"enter a"<<endl;
		cin>>a;
	}

	friend void Big(Test1 s1,Test2 s2);
};

class Test2
{
private:
	int b;

public:
	void Getb()
	{
		cout<<"enter b"<<endl;
		cin>>b;
	}

	friend void Big(Test1 s1,Test2 s2);
};


void Big(Test1 s1,Test2 s2)
{
	if(s1.a>s2.b)
		cout<<"a is grater"<<endl;
	else if(s1.a<s2.b)
		cout<<"b is grater"<<endl;
	else
		cout<<"both are equal"<<endl;
}

void main()
{
	Test1 T1;

	T1.Geta();

	Test2 T2;

	T2.Getb();

	Big(T1,T2);
}

 
 
Factory design pattern UML
 

 
Function template:
It is a way to make ur function or class generalized as far as data type is concerned.
#include<iostream>
#include<conio.h>

using namespace std;

//function templates (generic function)

template<class X>   //replaces x with datatype during binding depending on type of //argument passed during function call

X big(X a,X b)
{
	if(a>b)
		return a;
	else
		return b;
}
void main()
{

  cout<<big(4,5)<<endl;

  cout<<big(4.5,5.6)<<endl;

}

Class template syntax:
template <class type>
class class_name
{
};
 
 
 
 
Smart pointers(auto ptr)
Myclass *p;
P new myclass();
p->do(); //if it crashes here u wil not be deleting p .this is problem
delete p;
 
for this we use smart pointer:
 
 
 
Inheritance naresh
Inheritance reusability and extensibility;
 
Class x;
 
Class y:public class x;  //x methods in y that is reusability
//u can add new things that is extensiblity
 
Class z:public class y;
 
X is direct base class
Yis intermediate bas class;
When derived class object is created that time memory is allocatedto base and derived calss members 
class X
{
	int a,b;
};

class Y:public X
{
	int c,d;
};

void main()
{
	Y object;  //object has a,b,c,d and memory allocated 4*4=16 bytes in stack
}
 
Empty class has 1 byte memory.
#include<iostream>
#include<conio.h>
#include<string.h>

using namespace std;


class base
{
private:
	int x;
public:
	int y;
protected:
	int z;
};

class der1:public base      //all base class members 
{
public:
	int y;  //y of base become public in der1

protected:
	int z;   //z of base become protected in der1
};


class der2:private base      //all base class members 
{
public:
	int y;  //y of base become private in der2

protected:
	int z;   //z of base become private in der2
};

//in public or private derivation private membeers of base class are not avalable in derived class.They dont participate in inheritance.
//it follows data hiding 
//private members can only be accessed by member functions

Types of inheritance
1.single
2.multi level
3.multiple—deriving a class using more than one base class
4.hybrid
5.hierarchical
 
Multiple inheritance:
class X
{
};

class Y
{
};

class Z:public X,public Y
{
};

Necessary of protected members:can be accessed in declared class and immediate derived class
class student
{
	//id,name;
};

class marks
{
	//m1,m2,m3;   //cant make pulic //if private only tht class can accaess //so make it protected
};

class result:public student,public marks
{
};

//multilevel inheritance 
class student
{
	//id,name;
};

class marks:public student
{
	//m1,m2,m3;   
};

class xyz:public marks
{
};



 
 
 
 
 
 
 
Can static functions be virtual in C++?
 In C++, a static member function of a class cannot be virtual. For example, below program gives compilation error.
#include<iostream>
 
using namespace std;    
  
class Test
{
   public:
      // Error: Virtual member functions cannot be static      
      virtual static void fun()  { }
};

Run on IDE
Also, static member function cannot be const and volatile. Following code also fails in compilation.
#include<iostream> 
using namespace std; 
  class Test
{
   public:
      // Error: Static member function cannot be const
      static void fun() const { } 
};

The following program shows overloading of main() function in a class.
#include <iostream>
using namespace std;
class Test
{
public:
    int main(int s)
    {
        cout << s << "\n";
        return 0;
    }
    int main(char *s)
    {
        cout << s << endl;
        return 0;
    }
    int main(int s ,int m)
    {
        cout << s << " " << m;
        return 0;
    }
};
int main()
{
    Test obj;
    obj.main(3);
    obj.main("I love C++");
    obj.main(9, 6);
    return 0;
}

 
Overloading doesn’t work for derived class in C++ programming language. There is no overload resolution between Base and Derived. The compiler looks into the scope of Derived, finds the single function “double f(double)” and calls it. It never disturbs with the (enclosing) scope of Base. In C++, there is no overloading across scopes – derived class scopes are not an exception to this general rule
 
#include <iostream>
using namespace std;
class Base
{
public:
    int f(int i)
    {
        cout << "f(int): ";
        return i+3;
    }
};
class Derived : public Base
{
public:
    double f(double d)
    {
        cout << "f(double): ";
        return d+3.3;
    }
};
int main()
{
    Derived* dp = new Derived;
    cout << dp->f(3) << '\n';
    cout << dp->f(3.3) << '\n';
    delete dp;
    return 0;
}

Run on IDE
The output of this program is:
f(double): 6.3
f(double): 6.6 
 
 
C++ allows member methods to be overloaded on the basis of const type. Overloading on the basis of const type can be useful when a function return reference or pointer. We can make one function const, that returns a const reference or const pointer, other non-const function, that returns non-const reference or pointer. See this for more details.
 
1Functions that cannot be overloaded in C++
1) Function declarations that differ only in the return type. For example, the following program fails in compilation.
#include<iostream>
int foo() { 
  return 10; 
}
 
char foo() { 
  return 'a'; 
}
 
int main()
{
   char x = foo();
   getchar();
   return 0;
}

Run on IDE
2) Member function declarations with the same name and the name parameter-type-list cannot be overloaded if any of them is a static member function declaration. For example, following program fails in compilation.
#include<iostream>
class Test {
   static void fun(int i) {}
   void fun(int i) {}   
};
 
int main()
{
   Test t;
   getchar();
   return 0;
}

Run on IDE
3) Parameter declarations that differ only in a pointer * versus an array [] are equivalent. That is, the array declaration is adjusted to become a pointer declaration. Only the second and subsequent array dimensions are significant in parameter types. For example, following two function declarations are equivalent.
int fun(int *ptr);
int fun(int ptr[]); // redeclaration of fun(int *ptr)

Run on IDE
4) Parameter declarations that differ only in that one is a function type and the other is a pointer to the same function type are equivalent.
void h(int ());
void h(int (*)()); // redeclaration of h(int())

Run on IDE
5) Parameter declarations that differ only in the presence or absence of const and/or volatile are equivalent. That is, the const and volatile type-specifiers for each parameter type are ignored when determining which function is being declared, defined, or called. For example, following program fails in compilation with error “redefinition of `int f(int)’ “
Example:
#include<iostream>
#include<stdio.h>
  
using namespace std;
  
int f ( int x) {
    return x+10;
}
 
int f ( const int x) {
    return x+10;
}
 
int main() {     
  getchar();
  return 0;
}




We can call constructor and destructor explicitly
#include <iostream>
using namespace std;
 
class Test
{
public:
    Test()  { cout << "Constructor is executed\n"; }
    ~Test() { cout << "Destructor is executed\n";  }
};
 
int main()
{
    Test();  // Explicit call to constructor
    Test t; // local object
    t.~Test(); // Explicit call to destructor
    return 0;
}

Output:
Constructor is executed
Destructor is executed
Constructor is executed
Destructor is executed
Destructor is executed 
When the constructor is called explicitly the compiler creates a nameless temporary object and it is immediately destroyed. That’s why 2nd line in the output is call to destructor.



Can we have virtual constructor?
virtual functions aid in dynamic binding -> which happens at run-time -> objects are created at run-time -> objects creation requires constructor

If we make constructor as virtual in base, it means that it could be redefined in derived. Keep in mind that constructor is invoked during object creation (object is not created yet. still it is in the status "creating". Object will create only after executing constructor part code). Assume you are trying to create object of the class which has virtual constructor. During this process constructor of the class will be invoked. It looks for virtual keyword. Now it tries to look for virtual constructor in derived. But not possible bcz there is no vptr and no vtable avaibale at this point of time. So, when object is not created, then there is no vptr. If no vptr for this object, then how the consturtor of derived is invoked?. No address of this construtor will available in vtable.
Hence there is no point in having virtual constructor

Can we make a class constructor virtual in C++ to create polymorphic objects? No. C++ being static typed (the purpose of RTTI is different) language, it is meaningless to the C++ compiler to create an object polymorphically. The compiler must be aware of the class type to create the object. In other words, what type of object to be created is a compile time decision from C++ compiler perspective. If we make constructor virtual, compiler flags an error. In fact except inline, no other keyword is allowed in the declaration of constructor.
STATIC OBJECTS:
What are static objects in C++?
An object become static when static keyword is used in its declaration. See the following two statements for example in C++.
Test t;             // Stack based object
static Test t1;     // Static object 
First statement when executes creates object on stack means storage is allocated on stack. Stack based objects are also called automatic objects or local objects. static object are initialized only once and live until the program terminates. Local object is created each time its declaration is encountered in the execution of program..
static objects are allocated storage in static storage area. static object is destroyed at the termination of program. C++ supports both local static object and global static object 


What happens when we write only a copy constructor – does compiler create default constructor?
Compiler doesn’t create a default constructor if we write any constructor even if it is copy constructor. 
What about reverse – what happens when we write a normal constructor and don’t write a copy constructor?
Reverse is not true. Compiler creates a copy constructor if we don’t write our own. Compiler creates it even if we have written other constructors in class. For example, the below program works fine.

So we need to write copy constructor only when we have pointers or run time allocation of resource like file handle, a network connection, etc
Write example pgm to show why we need copy constructorwhen we have pointers in a class

C++ allows even built-in type (primitive types) to have default constructors
#include <iostream>
using namespace std;
 
int main() {
 
   cout << int() << endl;
   return 0;
}           //compiles no error is shown

Vvvvvvvvvvvvvvvvvvvvvimp destructor puzzle
#include <iostream>
using namespace std;
 
int i;
 
class A
{
public:
    ~A()
    {
        i=10;
    }
};
 
int foo()
{
    i=3;
    A ob;
    return i;
}
 
int main()
{
    cout << "i = " << foo() << endl;
    return 0;
}

Run on IDE
Output of the above program is “i = 3”.
Why the output is i= 3 and not 10? 
While returning from a function, destructor is the last method to be executed. The destructor for the object “ob” is called after the value of i is copied to the return value of the function. So, before destructor could change the value of i to 10, the current value of i gets copied & hence the output is i = 3.
How to make the program to output “i = 10” ? 
Following are two ways of returning updated value:
1) Return by Reference:
Since reference gives the l-value of the variable,by using return by reference the program will output “i = 10”.
#include <iostream>
using namespace std;
 
int i;
 
class A
{
public:
    ~A()
    {
        i = 10;
    }
};
 
int& foo()
{
    i = 3;
    A ob;
    return i;
}
 
int main()
{
    cout << "i = " << foo() << endl;
    return 0;
}

Run on IDE
The function foo() returns the l-value of the variable i. So, the address of i will be copied in the return value. Since, the references are automatically dereferened. It will output “i = 10”.


2. Create the object ob in a block scope
#include <iostream>
using namespace std;
 
int i;
 
class A
{
public:
    ~A()
    {
        i = 10;
    }
};
 
int foo()
{
    i = 3;
    {
        A ob;
    }
    return i;
}
 
int main()
{
    cout << "i = " << foo() << endl;
    return 0;
}

Run on IDE
Since the object ob is created in the block scope, the destructor of the object will be called after the block ends, thereby changing the value of i to 10. Finally 10 will copied to the return value.







Private Destructor
Predict the output of following programs.
#include <iostream>
using namespace std;
 
class Test
{
private:
   ~Test() {}
};
int main()
{ }

Run on IDE
The above program compiles and runs fine. It is not compiler error to create private destructors. What do you say about below program.
#include <iostream>
using namespace std;
 
class Test
{
private:
   ~Test() {}
};
int main()
{ 
  Test t; 
}

Run on IDE
The above program fails in compilation. The compiler notices that the local variable ‘t’ cannot be destructed because the destructor is private. What about the below program?
#include <iostream>
using namespace std;
 
class Test
{
private:
   ~Test() {}
};
int main()
{ 
   Test *t;
}

Run on IDE
The above program works fine. There is no object being constructed, the program just creates a pointer of type “Test *”, so nothing is destructed. What about the below program?
#include <iostream>
using namespace std;
 
class Test
{
private:
   ~Test() {}
};
int main()
{ 
   Test *t = new Test;
}

Run on IDE
The above program also works fine. When something is created using dynamic memory allocation, it is programmer’s responsibility to delete it. So compiler doesn’t bother.
The below program fails in compilation. When we call delete, desturctor is called.
#include <iostream>
using namespace std;
 
class Test
{
private:
   ~Test() {}
};
int main()
{ 
   Test *t = new Test;
   delete t;
}

Initialization of data members
When do we use Initializer List in C++?
For initialization of non-static const data members:
For initialization of reference members:
For initialization of member objects which do not have default constructor:
For initialization of base class members 
When constructor’s parameter name is same as data member
For Performance reasons:
It is better to initialize all class variables in Initializer List instead of assigning values inside body. Consider the following example:
// Without Initializer List
class MyClass {
    Type variable;
public:
    MyClass(Type a) {  // Assume that Type is an already
                     // declared class and it has appropriate 
                     // constructors and operators
      variable = a;
    }
};

Here compiler follows following steps to create an object of type MyClass
1. Type’s constructor is called first for “a”.
2. The assignment operator of “Type” is called inside body of MyClass() constructor to assign
	variable = a; 
3. And then finally destructor of “Type” is called for “a” since it goes out of scope.
With the Initializer List, following steps are followed by compiler:
1. Copy constructor of “Type” class is called to initialize : variable(a). The arguments in initializer list are used to copy construct “variable” directly.
2. Destructor of “Type” is called for “a” since it goes out of scope.
As we can see from this example if we use assignment inside constructor body there are three function calls: constructor + destructor + one addition assignment operator call. And if we use Initializer List there are only two function calls: copy constructor + destructor call. See this post for a running example on this point.



 
#include<iostream>
 
using namespace std;
 
class Test {
  private:    
    int y;
    int x;    
  public:
    Test() : x(10), y(x + 10) {}
    void print();
};
 
void Test::print()
{ 
   cout<<"x = "<<x<<" y = "<<y; 
}
 
int main()
{
    Test t;
    t.print();
    getchar();
    return 0;    
}
 
The program prints correct value of x, but some garbage value for y, because y is initialized before x as it appears before in the class declaration. 
 
So one of the following two versions can be used to avoid the problem in above code.
// First: Change the order of declaration.
class Test {
  private:    
    int x;    
    int y;
  public:
    Test() : x(10), y(x + 10) {}
    void print();
};

Run on IDE
// Second: Change the order of initialization.
class Test {
  private:    
    int y;
    int x;    
  public:
    Test() : x(y-10), y(20) {}
    void print();
};

 
 
 
 
 
 
 
 
 
 
 
 
 
When is copy constructor called?
In C++, a Copy Constructor may be called in following cases:
1. When an object of the class is returned by value.
2. When an object of the class is passed (to a function) by value as an argument.
3. When an object is constructed based on another object of the same class.
4. When compiler generates a temporary object.
 
UML diagrams important 
A class representation
1
2
3
4
5
6
7
8
9
10
class Circle {
private:
double radius;
Point center;
public:
setRadius(double radius);
setCenter(Point center);
double getArea();
double getCircumfrence();
};

Class diagram for the above class is shown below.

Different visibility of the class can be represented as
“+” Public
“-” Private
“#” Protected
Different Parameter direction
“in”           The parameter is an input parameter.
“Inout”    The parameter is capable of both input and output.
“Out”        The parameter is an output parameter.
Different type of members in a class
1) Static members are represented as underlined.
2) Pure virtual functions are represented as italics.
 
 
Association
One object is aware of another; it contains a pointer or reference to another object.
Representaion

C++ Example
1
2
3
4
5
6
7
8
9
10
Class X {
 
  X(Y *y) : y_ptr(y) {}
 
  void SetY(Y *y) { y_ptr = y;   }
 
  void f()        { y_ptr->Foo();}
  ----
  Y *y_ptr; // pointer
};

 
Dependency
One class depends on another if the independent class is a parameter variable or local variable of a method of the dependent class
Representaion

C++ Example
1
2
3
4
5
6
7
8
9
class X {
 ...
 void f1(Y y)  {…;  y.Foo();       }
 void f2(Y *y) {…;  y->Foo();      }
 void f3(Y &y) {…;  y.Foo();       }
 void f4()     {   Y y; y.Foo();  …}
 void f5()     {…; Y::StaticFoo(); }
 ...
};

 
Aggregation
Aggregation can occur when a class is a collection or container of other classes, but where the contained classes do not have a strong life cycle dependency on the container—essentially, if the container is destroyed, its contents are not. You may have confusion between aggregation and association .Association differs from aggregation only in that it does not imply any containment.
 Representaion
 
Example 2:
A car has it’s tiers, and the scope of tyre doesn’t depend on a car since a tyre can be used for another car also

Composition
Composition is the stronger form of aggregation. Composition can occur when a class is a collection or container of other classes, but where the contained classes have a strong life cycle dependency on the container—essentially, if the container is destroyed, its contents are also destroyed
Representation

C++ Example
1
2
3
4
5
6
7
class Circle
{
private:
     ...
    Point center;
....
};

 
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
class X {
...
Y a; // 1; Composition
Y b[10]; // 0..10; Composition
};
 
class X {
X() { a = new Y[10]; }
~X(){ delete [] a; }
...
Y *a; // 0..10; Composition
};
 
class X {
...
vector a;
};

Inheritance (Generalization)
In Inheritance relationship a class is derived from another class. It is a “is a” relationship between two classes.
Representation

Here X and Y are normal classes.
 
Here Shape is an abstract class that is why it is shown in Italics. Draw () and Erase () methods of Shape class is pure virtual function, so it is also shown as italics.
Class Template
Template class mean generic classes.Languages like C++, java, C# supports generic programming.
Representation

C++ represenatation
1
2
3
4
5
6
7
8
9
10
template <class T>
class X {
...
...
...
};
X Y
...
X<Y> a;
...

 
 
 
 
 
 
 
Input/Output Operators Overloading in C++ C++ is able to input and output the built-in data types using the stream extraction operator >> and the stream insertion operator <<. The stream insertion and stream extraction operators also can be overloaded to perform input and output for user-defined types like an object.
 
 
when do preprocessor directives get executed
a. before compilation
 
 
When can u make private destructor?
If its private u cant create object on stack.U have to crate object on heap,but u cant call delte  on it as its private.If u want ur object should be always in  memory u can do it private.
 
 
Example for refrence as a return value
 
#include<iostream>
#include<conio.h>
#include<stdlib.h>

#include<string.h>

using namespace std;


int a[3]={10,20,30};

int &SetValue(int i)
{
	return a[i];
}


void main()
{	

	cout<<"values before change are"<<endl;

	for(int i=0;i<3;i++)
		cout<<a[i]<<endl;

	SetValue(1) = 1000;

	SetValue(3) = 2000;

	cout<<"values after change are"<<endl;

	for(int i=0;i<3;i++)
		cout<<a[i]<<endl;

}
 
 
 
 
FUNCTION POINTERS:
Syntax for the function pointer is as follows:
(return type)(*pointer name)(argument type);
 
Example: void Add(int x,int y);
Function pointer for above is 
 
Void (*ptr)(int,int);
 
Calling function using pointer:
 
Ptr = Add ; or   ptr =&Add;
 
Ptr(10,20);  or (*ptr)(10,20);
 
Example program as follows::::::::
 
#include<iostream>
#include<conio.h>

using namespace std;


void Add(int x,int y)
{
	cout<<"value of x is "<<x<<endl;
	cout<<"value of y is "<<y<<endl;

	cout<<"sum of x and y is"<<x+y<<endl;
}


void Sub(int m,int n)
{
	cout<<"substraction of m and n is "<<m-n<<endl;
}


void main()
{
	int a,b;

	cout<<"enter the value of a"<<endl;
	cin>>a;

	cout<<"enter the value of b"<<endl;
	cin>>b;

	void (*ptr)(int,int);

	ptr = Add;

	(ptr)(a,b);

	ptr = Sub;

	(ptr)(a,b);
}


Another example for function pointer:
 
#include<iostream>
#include<conio.h>

using namespace std;


void VoidFunction()
{
  cout<<"Its a void function"<<endl;
}


int  IntFunction(int m)
{
	return m+5;
}


void main()
{
	int m;

	void(*ptrvoid)();

	int (*ptrint)(int);

	ptrvoid = VoidFunction;

	ptrvoid();

       ptrint = IntFunction;
	 m = ptrint(5);

	 cout<<m<<endl;

}


Introduction to Pointers:
 
 
 
 
 
1Virtual Base classes::: vvvvvvvvvvvvvvvvvvvvvvvimp
#include<iostream>
#include<conio.h>

using namespace std;

class Base
{
public:
	int a;
};

class Derived1:public Base
{
public:
	int b;  //has one copy of a
};

class Derived2:public Base
{
public:
	int c;  //has one copy of a
};

class Derived3:public Derived1,public Derived2
{
public:
	int d;       //has 2 copy of a
};


void main()
{
	Derived3 Y;

	Y.a = 20; //which a of Derived1 or Derived2??????compile error
}
 
Above problem can be overcome by 2 ways
 
1. Using the scope resolution operator:
Follow modification in main as follows
 
void main()
{
	Derived3 Y;

	Y.Derived1::a = 20; //which a of Derived1 or Derived2??????
}
 
2. Using the virtual base class: Is there a way to prevent 2 copies of base being included in a derived class?
See modifications as shown below
 
#include<iostream>
#include<conio.h>

using namespace std;

class Base
{
public:
	int a;
};

class Derived1:virtual public Base
{
public:
	int b;  //has one copy of a
};

class Derived2:virtual public Base
{
public:
	int c;  //has one copy of a
};

class Derived3:public Derived1,public Derived2
{
public:
	int d;       //has 2 copy of a
};


void main()
{
	Derived3 Y;

	Y.a = 20; 
}
 
The difference between normal base class and virtual base class is what occurs when an object inherits the base more than once. If virtual classes are used, then only one base class is present in the object. Else multiple copies will be found.
 
 
 
 
 
What is a bubble sort in C++?
In the bubble sort, as elements are sorted they gradually "bubble" (or rise) to their proper location in the array, like bubbles rising in a glass of soda. The bubble sortrepeatedly compares adjacent elements of an array. The first and second elements are compared and swapped if out of order.
 
In bigining of pgm why we include iostream.h???
Becoz various input and output objects are declared in that header file.Once we declare header file all the identifiers are treated as global and can be used in our programs.
 
Why we use using namespace std??
Std namespace is a standard namespace in C++ which encompasses the standard classes,standard functions and standard templates tht we use while writing C++ pgms.
 
Namespace eample program:
 
#include<iostream>
#include<conio.h>

using namespace std;

namespace xyz
{
	int m=10;
}

namespace pqr
{
	float  m=15.3546;
}


void main()
{
	
	cout<<"value of m is"<<xyz::m<<endl;


	cout<<"value of m is"<<pqr::m<<endl;

}
 
 
 
 
 
 
 
 
 
 
 
Scope of variables in C++ vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvimp
 
1.Global Scope::::
2.Local Scope
3.Static Scope
4.Class Scope
5.Namespace scope
 
 
Variables that are defined outside class are called global variables.
The memory for global variables will be allocated before the execution of function main()
All global variables are initialized to zero.
Globle variables are not passed as parameters .
http://www.csee.umbc.edu/~chang/cs202/Lectures/modules/m03a-pointers/slides.php?print
 
Object: Objects are basic run-time entities in an object oriented system, objects are instances of a class these are user defined data types.

ex:
class person
{
    char name[20];
    int id;
public:
    void getdetails(){}
};
 
int main()
{
   person p1; //p1 is a object 
}


Object take up space in memory and have an associated address like a record in pascal or structure or union in C.
When a program is executed the objects interact by sending messages to one another.
Each object contains data and code to manipulate the data. Objects can interact without having to know details of each others data or code, it is sufficient to know the type of message accepted and type of response returned by the objects

Class: A class in C++ is a user defined type or data structure declared with keyword class that has data and functions (also called methods) as its members ,whose access is governed by the three access specifiers private, protected or public (by default access to members of a class is private). 
 	Class is a blueprint of data and functions or methods. Class does not take any space.
syntax for class:
class class_name
{
  private:
     //data members and member functions declarations
  public:
     //data members and member functions declarations
  protected:
     //data members and member functions declarations
};


Class is a user defined data type like structures and unions in C.
By default class variables are private but in case of structure it is public. in above example person is a class. 
Structure vs class in C++
In C++, a structure is same as class except the following differences: 
1) Members of a class are private by default and members of struct are public by default.
For example program 1 fails in compilation and program 2 works fine.
// Program 1
#include <stdio.h>
 
class Test {
    int x; // x is private
};
int main()
{
  Test t;
  t.x = 20; // compiler error because x is private
  getchar();
  return 0;
}


2) When deriving a struct from a class/struct, default access-specifier for a base class/struct is public. And when deriving a class, default access specifier is private.
For example program 3 fails in compilation and program 4 works fine.
// Program 3
#include <stdio.h>
 
class Base {
public:
    int x;
};
 
class Derived : Base { }; // is equilalent to class Derived : private Base {}
 
int main()
{
  Derived d;
  d.x = 20; // compiler error becuase inheritance is private
  getchar();
  return 0;
}


You have to use public method to call private method of class 
Difference between MALOOC and NEW
1. Following are the differences between malloc() and operator new. 
1) new calls constructors, while malloc() does not. In fact primitive data types (char, int, float.. etc) can also be initialized with new. For example, below program prints 10.
#include<iostream>
 
using namespace std;
 
int main()
{
   int *n = new int(10); // initialization with new()
   cout<<*n;
   getchar();
   return 0;
}

2) new is an operator, while malloc() is a fucntion.
3) new returns exact data type, while malloc() returns void *. Since malloc returns void pointer it is necessary to explicitly typecast it in to an appropriate type of pointer.Example as follows
double* pvalue  = NULL; // Pointer initialized with null
pvalue  = new double;   // Request memory for the variable

Int *p=(int*)malloc(sizeof(int));

MEMORY ALLOCATION FUNCTIONS:
Static and dynamic allocations  VTU BOOOK

Example for dangling pointer:

void main()
{
	int *p;
	int *q=new int;
	p=q;

	delete q;
}
Suppose we allocate a chunk of memory and store its address in pointer.If this chunk of memory is freed and if the pointer continues to point to tht location,then poiunter is said to be dangling.
In above example p and q point to same location.deleting p frees memory,but p keeps pointing so its dangling.


Static Memory Allocation: Memory is allocated for the declared variable by the compiler. The address can be obtained by using ‘address of’ operator and can be assigned to a pointer. The memory is allocated during compile time. Since most of the declared variables have static memory, this kind of assigning the address of a variable to a pointer is known as static memory allocation.

Dynamic Memory Allocation: Allocation of memory at the time of execution (run time) is known as dynamic memory allocation. The functions calloc() and malloc() support allocating of dynamic memory. Dynamic allocation of memory space is done by using these functions when value is returned by functions and assigned to pointer variables.

#include<iostream>
#include<conio.h>

using namespace std;

class X
{
private:
	int x;
	int Get();

public:
	void Getx();
	void Setx(int x);
};

void X::Setx(int x)
{
	this->x=x;
}
void X::Getx()
{
	Get();
	cout<<"x is"<<x<<endl;
}

int X::Get()
{
	return x;
}
int main()
{
	X x;

	x.Setx(4);
	x.Getx();

	//getch();
	return 0;
}
Data members of a class should not be initialized when they are declared.Example as shown
class X
{
private:
	int x=10;//error :data member initialization not allowed
	int Get();

public:
	void Getx();
	void Setx(int x);
};
Instead data members can be initialized using the member functions.You can use set and get methods.Exmaple as shown below

#include<iostream>
#include<conio.h>

using namespace std;

class X
{
private:
	int x;

public:
	int Getx();
	void Setx(int a);
};

void X::Setx(int a)
{
	x=a;
}

int X::Getx()
{
	return x;
}

int main()
{
	X x;
	int value;
	x.Setx(5);
	value= x.Getx();

	cout<<"value of x is"<<value<<endl;

	getch();
	return 0;
}


Class objects and accessing class members
We can access the class members using dot operator(.)

In the above example x.Setx(5);
We can access the members using the arrow oerator(->)
int main()
{
X x;
		X *p1;
		p1=&x;		
		p1->Setx(5);
Return 0;
}
NOTE:
Declaration of class does not reserve any memory for any data members and member functions.
Memory is reserved only when objects are created.
It’s not possible to access private members of class of a class outside class.
Separate memory is reserved for data members of each object, but a single copy of member functions is shared by various objects.


This Pointer in C++
Every object in C++ has access to its own address through an important pointer called this pointer. The  this pointer is an implicit parameter to all member functions. Therefore, inside a member function, this may be used to refer to the invoking object.
The ‘this’ pointer is passed as a hidden argument to all nonstatic member function calls and is available as a local variable within the body of all nonstatic functions. 
‘this’ pointer is a constant pointer that holds the memory address of the current object. 
‘this’ pointer is not available in static member functions as static member functions can be called without any object (with class name).
For a class X, the type of this pointer is ‘X* const’. Also, if a member function of X is declared as const, then the type of this pointer is ‘const X *const’ (see this GFact)
Friend functions don’t have this pointer becoz they are not members of class.Only member functions have this pointer.
When a member function is called how does c++ keep track of which object it was called is by this pointer.
This pointer is very useful feature in C++ when operators are overloaded.
Following are the situations where ‘this’ pointer is used:
Following are the situations where ‘this’ pointer is used:
 
1) When local variable’s name is same as member’s name
#include<iostream>
using namespace std;
 
/* local variable is same as a member's name */
class Test
{
private:
   int x;
public:
   void setX (int x)
   {
       // The 'this' pointer is used to retrieve the object's x
       // hidden by the local variable 'x'
       this->x = x;
   }
   void print() { cout << "x = " << x << endl; }
};
 
int main()
{
   Test obj;
   int x = 20;
   obj.setX(x);
   obj.print();
   return 0;
}

2) To return reference to the calling object
/* Reference to the calling object can be returned */
Test& Test::func ()
{
   // Some processing
   return *this;
} 








Explain this pointer:
Class A
{
Public:
Void f();               
}

int main()
{
A obj;
Obj.f();
Return 0;
}

The keyword this in the body of f() stores the address of the object obj.
Type of this pointer for a member function of class A is A* const.
So when we cal f() we actually calling f(&objA)
Void A:: f(){} is converted to void A::f(A*const this)

when a nonstatic member function is called for an object the address of an object is passed by the compiler as a hidden argument to the function.

Example program to show use of this pointer

#include<iostream>
#include<conio.h>
using namespace std;

class Interest
{
private:
	double p,t,r;

public:
	void GetData();
	void PutData();
	void Compute();
};

void Interest::GetData()
{
	cout<<"enter the value of p,t and r";
	cin>>this->p>>this->t>>this->r;
}

void Interest::PutData()
{
	cout<<"value of P is"<<this->p<<endl;
	cout<<"value of T is"<<this->t<<endl;
	cout<<"value of R is"<<this->r<<endl;
}

void Interest::Compute()
{
	double si=(this->p)*(this->t)*(this->r)/100;
	cout<<"value of si is "<<si<<endl;
}


void main()
{
	Interest obj;

	obj.GetData();
	obj.PutData();
	obj.Compute();
}
 


NAMASPACES:READ FROM VTU BOOK THEORY PAGE 2.21

#include<iostream>
#include<conio.h>

using namespace std;

namespace xyz
{
	int m=5;
}


namespace pqr
{
	float n=55.345;
}



int main()
{

	using namespace xyz;

	cout<<"value of m is"<<m<<endl;
	m=23;
	cout<<"value of m in xyz is "<<m<<endl;

	using namespace pqr;

	cout<<n<<endl;
	n=11110.2546;
	cout<<"value of m in pqr is now"<<n<<endl;


	return 0;
}




Accessing identifiers of a namespace using scoperesolution operator:


Name::identifier
#include<iostream>
#include<conio.h>

using namespace std;

namespace xyz
{
	int m=5;
}

namespace pqr
{
	float m=3.156;
}

int main()
{
	cout<<"value of m is"<<xyz::m<<endl;

	cout<<"value of m in pqr is"<<pqr::m<<endl;

	m=200;  //error because m defined in the namespaces xyz and pqr are local to those namespaces and are undefined outside namespaces

	return 0;
}

NAMESPACE STD:

In our program we write using namespace std; 
The above statement specifiew that the members(data members and members functions and standarad objects such as cout,cin,endl etc ) defined in the std namespaces will be used frequently in the program.hence std namespace is termed as a standard namespace(whichrefers to entire source code)


STATIC VARIABLE:
The variables that are defined using static are called static variables.
They can be declared outside classes,inside functions
If they are declared outside they are global variables and if they are declared inside the block they are  local variables.
Life span of any static variable is same as the life span of global variable ie once the memory for static variables is allocated they are destroyed before function main() is terminated.
All static variables are initialized to zero by default.


STATIC MEMBERS:
Static data members are the members defined inside a class that are used to hold the data that are common to all the objects of a class. 
When we declare a member of a class as static it means no matter how many objects of the class are created, there is only one copy of the static member.
Static data members should be declared globally Using the scope resolution operator(::)
By Default static members are initialized to zero.
Example:

Class X
{
Static int a;
}

int X::a=10;           //redeclared outside class is a must

following example show by default value of static member is zero.
#include<iostream>
#include<conio.h>

using namespace std;

class X
{
private:
	static int a;

public:
	int Getx();
	void Setx(int x);
};

int X::a;

int X::Getx()
{
	return a;
}
int main()
{
	X obj;
	cout<<"value of x is"<<obj.Getx()<<endl;
	return 0;
}



Accesssing static data members:
#include<iostream>
#include<conio.h>

using namespace std;

class X
{
private:
	static int a;
	int b;

public:
	void initialize(int x,int y);
	void display();
};

int X::a;

void X::initialize(int x,int y)
{
	a=x;
	b=y;
}

void X::display()
{
	cout<<"static is"<<a<<endl;
	cout<<"nonstatic is"<<b<<endl;
}

int main()
{
	X x1,x2,x3;

	x1.initialize(10,20);
	x1.display();

	x2.initialize(30,40);
	x2.display();

	getch();
	return 0;
}



Features of static data members:
size of a class or object is obtained without considering size of static data members.
It is possible to access static data members using member functions
Count of objects can be found easily.
A static data member exists much before any object of its calss is created.
Static data member can appear as the default value for the formal parameters of member funts of its class.

class X
{                                 vvvvvimp
private:
	static int a;
	int b;

public:
	void initialize(int x=a);           ///correct as a is static 
	void display(int y=b);            ////error as b is non static 
};

Size of class with or without static data member
Since static data members are not contained within objects ,introducing the static data members does not increase the size of objects of the class.
#include<iostream>
#include<conio.h>

using namespace std;

class X
{
private:
	int a;
	float b;
	double d;
};

void main()
{
	cout<<"size of class X is"<<sizeof(X)<<endl;

	getch();
}
 Output is :  16

#include<iostream>
#include<conio.h>

using namespace std;

class X
{
private:
	int a;
	float b;
	double d;
	static int s;
};

int X::s=10;

void main()
{
	cout<<"size of class X is"<<sizeof(X)<<endl;

	getch();
}

Output is ::::::16


Find number of objects using satic data member:

#include<iostream>
#include<conio.h>

using namespace std;

class X
{
public:
	static int count;
	X(){count++;}
};

int X::count;

void main()
{
	X a;
	cout<<"number of objects"<<a.count<<endl;

	X b;
	cout<<"number of objects"<<b.count<<endl;

	X c;
	cout<<"number of objects"<<c.count<<endl;

	getch();
}


Size of empty class is 1 byte.Example is as shown below
#include<iostream>
#include<conio.h>

using namespace std;

class X
{

};

 

void main()
{
	cout<<"size of class x is"<<sizeof(X)<<endl;
	getch();
}

Existence of static data member before the object
The static data members exist much before any object of its class is created. this is because they can be treated as global variables which can be accessed by non member functions(if static members are declared under public).This can be shown by below example.

#include<iostream>
#include<conio.h>

using namespace std;

class X
{
public:
	static int a;
};


int X::a;
void main()
{
	X::a=20;
	cout<<"value of a is"<<X::a<<endl;

	X  b;
	cout<<"value using object is"<<b.a<<endl;
	getch();
}


NOTE:
By using the static data members we can virtually eliminate all the global variables in the program. We should avoid global variables becoz they violate the principle of data encapsulation.

STATIC MEMBER FUNCTIONS:
By declaring a function member as static, you make it independent of any particular object of the class. 
The main purpose of these functions is to access or modify the static data members of the class.
The keyword static should not appear in the function definition.
A static member function can be called even if no objects of the class exist and the static functions are accessed using only the class name and the scope resolution operator ::.
A static member function can only access static data member, other static member functions and any other functions from outside the class.
Static member functions have a class scope and they do not have access to this pointer of the class. 
You could use a static member function to determine whether some objects of the class have been created or not.
Static members can be invoked without any object or using object also.

Some important observations from below program
#include<iostream>
#include<conio.h>

using namespace std;


class X
{
private:
	static int a;
	int c;

public:
	static int b;

public: 
	static void display1();  //can access ony static members
	void display2();
};

int X::a=10;
int X::b=20;


void X::display1()
{
	cout<<a<<b<<endl;
	cout<<c<<endl; //error as static memeber function can access only static data memebers 
}

void X::display2()
{
	cout<<a<<b<<c<<endl;     //non static function can access both static and non static memebers 
}


int main()
{
	X ob;

	cout<<X::a<<endl;      //private memeber cannot be accesed
	cout<<X::b<<endl;

	return 0;
}

Observations:
1. Static members can be called using object or without using object.
2. Static members can access only static data members as shown in display1().
3. static members cannot access non static data members.
4. normal member functions can access static and non static data members.


SCOPE RESOLUTION OPERATOR AS AN UNARY OPERATOR
1. When a non member function and the member functions have the same name, a non member function can be called using scope resolution operator. Exmaple as follows

#include<iostream>
#include<conio.h>

using namespace std;


void display1()
{
	cout<<"non memeber function"<<endl;
}
class X
{
public:	
	int c;

public: 
	 void display1(); 
};


void X::display1()
{	
	cout<<"memebr function"<<endl;
}


int main()
{
	X x;

	x.display1();   //memeber function is called
	
	::display1();   //non memebr function is caled

	getch();
	return 0;
}

2.unary operator to access the  global variable.
Whenever the name of global variable and the local variable are same, preference is given to the local variable.
In such situation if we want to access the global variable value we use::as prefix to globa variable.

Example as shown below

#include<iostream>
#include<conio.h>

using namespace std;

int i=20;  //globa variable


int main()
{
int i=10;    //local variable

cout<<"value of local variable is "<<i<<endl;
cout<<"value of global variable is"<<::i<<endl;

	getch();
	return 0;
}	

#include<iostream>
#include<conio.h>

using namespace std;

int i=20;  //global variable                block1


int main()
{
	int i=10;    //local variable                block 2
 {
	int i=40;                     //block 3

	cout<<"value of local variable is "<<i<<endl;      //40
	cout<<"value of global variable is"<<::i<<endl;     //20
 }

    cout<<"value of local variable is "<<i<<endl;      //10
	cout<<"value of global variable is"<<::i<<endl;    //20


	getch();
	return 0;
}

Disadvantage:
In block 3 its not possible to use the value 40 this can be overcome using namespace.




CONSTRUCTORS:
Constructor is a special member function that is used to initialize the data members of an object.
Name of the constructor is same as that of class.
Constructor is automatically called when the object is created. It should not be called using an object as other member functions.
Constructors should be declared in public.
They don’t have any return value.
When to make constructor private:
When we want tht a user of tht class should not be able to create an object of that class but the member functions of the class should be able to create it.
One common use is in the singleton pattern where you want only one instance of the class to exist. In that case, you can provide a static method which does the instantiation of the object. This way the number of objects instantiated of a particular class can be controlled.

Following example shows use of private constructor:   VVVVVVVVVVVVVVVVVVVVVVVimp
This way of creating objects of a C++ class with private constructor is called as factory method. 
Note that the object of the C++ class is actually created by a static function and is passed to the main function as a pointer to the object. Once the main function receives the pointer to the Object of the C++ Class, it can call any functions and use the object just like any other way.
The above output of this sample c++ project confirms that the object of the C++ class was created by the static function. Such static functions of C++ classes whose responsibility is to create objects are referred to as factory methods and can be useful in a complex C++ Object creation procedure.




Program to show string initialization

#include<iostream>
#include<conio.h>
#include<string.h>

using namespace std;

class String
{
private:
	char *name;
	int len;

public:
	String(char *str=NULL);

	void Display();
};

String::String(char *str)
{
	if(str==NULL)
	{
		name=NULL;
		len=0;
		return;
	}

	len=strlen(str);
	name=new char[len+1];
	strcpy(name,str);
}

void String::Display()
{
	cout<<name<<len;
}

void main()
{
	String S1="RAMA";

	S1.Display();
}





#include<iostream>
#include<conio.h>

using namespace std;

class X
{
private:
	X(){cout<<"c++ constructor with private access"<<endl;}

public:
	static X* GiveMeClassObject()
	{
		return new X();
	}
};


int main()
{
	X *object;

	object= X::GiveMeClassObject();

	delete object;


	return 0;
}

1. Default Constructor: A constructor which does not take any arguments.
Disadvantages:
It is not possible to overload the default constructor.
When many objects of the class are created all objects are initialized to same set of values.
If we want to initialize different objects to different values its not possible using default constructor.

#include<iostream>
#include<conio.h>

using namespace std;

class X
{
private:
	int a,b;

public:
	X();
	void display();
};


X::X()
{
	a=10;
	b=20;
}

void X::display()
{
	cout<<"value of a and b is"<<a<<b<<endl;
}

int main()
{
	X ob1,ob2,ob3;

	ob1.display();
	ob2.display();

	getch();
	return 0;
}

2. Parameterized Constructor: Constructor that takes one or more arguments.
It is used to initialize different objects to different values.
These can be overloaded.
These can have default arguments. if all arguments are default it can be considered as default. 
1.Implicit call:declaration of objectis followed by the argument list enclosed within parenthesis.
#include<iostream>
#include<conio.h>

using namespace std;

class X
{
private:
	int x;

public:
	X(int a);	
};


X::X(int a)
{
	x=a;
}



int main()
{
    X ob(10);  //implicit call to parameterized constructor

	getch();
	return 0;
}

2.Explicit call:declaration of object followed by assignment operator followed by constructor followed by arg list.

X ob1=X(20);// explicit call


Using initialization list
#include<iostream>
#include<conio.h>

using namespace std;

class X
{
private:
	int a,b;

public:
	X(int x):a(x),b(x)
	{}

	void display()
	{
		cout<<"value of a is"<<a<<endl;
		cout<<"value of b is"<<b<<endl;
	}
};

int main()
{
	X ob1(5);

	ob1.display();

	X ob2(10);
	ob2.display();

	return 0;

}








COPY CONSTRUCTOR:
The copy constructor is a constructor which creates an object by initializing it with an object of the same class, which has been created previously. 
The copy constructor is used to:
Initialize one object from another of the same type.
Copy an object to pass it as an argument to a function.
Copy an object to return it from a function.
If a copy constructor is not defined in a class, the compiler itself defines one.
If the class has pointer variables and has some dynamic memory allocations, then it is a must to have a copy constructor. 
We can make copy constructor Private if we want to make objects of a class non copyable.

The most common form of copy constructor is shown here:
classname (const classname &obj) {
   // body of constructor
}
 

#include<iostream>
using namespace std;
 
class Point
{
private:
    int x, y;
public:
    Point(int x1, int y1) { x = x1; y = y1; }
 
    // Copy constructor
    Point(const Point &p2) {x = p2.x; y = p2.y; }
 
    int getX()            {  return x; }
    int getY()            {  return y; }
};
 
int main()
{
    Point p1(10, 15); // Normal constructor is called here
    Point p2 = p1; // Copy constructor is called here
 
    // Let us access values assigned by constructors
    cout << "p1.x = " << p1.getX() << ", p1.y = " << p1.getY();
    cout << "\np2.x = " << p2.getX() << ", p2.y = " << p2.getY();
 
    return 0;
}

Output:
p1.x = 10, p1.y = 15
p2.x = 10, p2.y = 15 



Why argument to a copy constructor must be passed as reference?
A copy constructor is called when we pass object by value.Copy constructor itself is a function.so if we pass argu by value in copy constructor ,a call to CC would be made to callCC which becomes non erminating.

When is copy constructor called?
In C++, a Copy Constructor may be called in following cases:
1. When an object of the class is returned by value.
2. When an object of the class is passed (to a function) by value as an argument.
3. When an object is constructed based on another object of the same class.
4. When compiler generates a temporary object. 

When is user defined copy constructor needed?
If we don’t define our own copy constructor, the C++ compiler creates a default copy constructor for each class which does a member wise copy between objects. The compiler created copy constructor works fine in general. We need to define our own copy constructor only if an object has pointers or any run time allocation of resource like file handle, a network connection..etc.

 
When the default copy constructor is called,exact copy of the original object is available due to bitwise copying.In such situations both the objects will share the same set of memory locations i.e. both of them point to same place 







 SHALOOW COPY:
#include<iostream>
#include<conio.h>

using namespace std;


class Dummy
{
private:
	int a,b;
public:
	void SetData(int x,int y)
	{
		a=x;
		b=y;
	}

	void ShowData()
	{
		cout<<"a is"<<a<<endl<<"b is"<<b<<endl;
	}

};

int main()
{
	Dummy d1;

	d1.SetData(3,4);

	Dummy d2=d1;

	d2.ShowData();


	getch();
	return 0;
}



Values are copied as it is,it wont copy memory resoureces.







When  we have pointer by shallow copy memory resource is being shared .Wedt want this.So we prefer deep copy so we have to write own copy constructor


	Dummy(const Dummy &d)
	{
		a=d.a;
		b=d.b;
		p=new int;
		*p=*(d.p);
	}
 We are creating different block ie memory resource is now not getting shared but we have separate memory resource for both objects.


Write program to show problems of using default copy constructor  vvvvvvvvvimp

#include<iostream>
#include<conio.h>

using namespace std;


class String
{
private:
	char *name;
	int len;

public:
	String(char *a)
	{
		len=strlen(a);
		name=new char[len+1];
		strcpy(name,a);
	}

	void display()
	{
		cout<<"name ="<<name<<endl;
		cout<<"length is"<<len<<endl;
	}
};

int main()
{
	String x("RAMA");

	String y= x;

	x.display();
	y.display();


	return 0;
}
 Above pgm can be modified as below by writing own copy constructor

String (const String &ob)
{
Len=strlen(ob.name);
Name=new char[len+1];
Strcpy(name,ob.name);
}

When should we write our own copy constructor?
Don’t write a copy constructor if shallow copies are ok: In C++, If an object has no pointers or any run time allocation of resource like file handle, a network connection..etc, a shallow copy is probably sufficient. Therefore the default copy constructor, default assignment operator, and default destructor are ok and you don’t need to write your own.


Copy constructor vs Assignment Operator
Which of the following two statements call copy constructor and which one calls assignment operator?
MyClass t1, t2;
MyClass t3 = t1;  // ----> (1)
t2 = t1;          // -----> (2) 

Can we make copy constructor private?
Yes, a copy constructor can be made private. When we make a copy constructor private in a class, objects of that class become non-copyable. This is particularly useful when our class has pointers or dynamically allocated resources. In such situations, we can either write our own copy constructor like above String example, or make a private copy constructor so that users get compiler errors rather than surprises at run time.

Why argument to a copy constructor must be passed as a reference?
A copy constructor is called when an object is passed by value. Copy constructor itself is a function. So if we pass argument by value in a copy constructor, a call to copy constructor would be made to call copy constructor which becomes a non-terminating chain of calls. Therefore compiler doesn’t allow parameters to be pass by value.

INITIALIZATION LIST CONSTRUCTOR:
#include<iostream>
using namespace std;
 
class Point {
private:
    int x;
    int y;
public:
    Point(int i = 0, int j = 0):x(i), y(j) {} 
    /*  The above use of Initializer list is optional as the 
        constructor can also be written as:
        Point(int i = 0, int j = 0) {
            x = i;
            y = j;
        }
    */   
     
    int getX() const {return x;}
    int getY() const {return y;}
};
 
int main() {
  Point t1(10, 15);
  cout<<"x = "<<t1.getX()<<", ";
  cout<<"y = "<<t1.getY();
  return 0;
}
 
/* OUTPUT:
   x = 10, y = 15
*/

But there are situations where initialization of data members inside constructor doesn’t work and Initializer List must be used. Following are such cases:
1. 1) For initialization of non-static const data members:
#include<iostream>
using namespace std;
 
class Test {
    const int t;
public:
    Test(int t):t(t) {}  //Initializer list must be used
    int getT() { return t; }
};
 
int main() {
    Test t1(10);
    cout<<t1.getT();
    return 0;
}
 
/* OUTPUT:
   10 
*/
2) For initialization of reference members:
Reference members must be initialized using Initializer List. In the following example, “t” is a reference member of Test class and is initialized using Initializer List.
// Initialization of reference data members
#include<iostream>
using namespace std;
 
class Test {
    int &t;
public:
    Test(int &t):t(t) {}  //Initializer list must be used
    int getT() { return t; }
};
 
int main() {
    int x = 20;
    Test t1(x);
    cout<<t1.getT()<<endl;
    x = 30;
    cout<<t1.getT()<<endl;
    return 0;
}
/* OUTPUT:
    20
    30
 */
3) For initialization of member objects which do not have default constructor:
In the following example, an object “a” of class “A” is data member of class “B”, and “A” doesn’t have default constructor. Initializer List must be used to initialize “a”.
#include <iostream>
using namespace std;
 
class A {
    int i;
public:
    A(int );
};
 
A::A(int arg) {
    i = arg;
    cout << "A's Constructor called: Value of i: " << i << endl;
}
 
// Class B contains object of A
class B {
    A a;
public:
    B(int );
};
 
B::B(int x):a(x) {  //Initializer list must be used
    cout << "B's Constructor called";
}
 
int main() {
    B obj(10);
    return 0;
}
/* OUTPUT:
    A's Constructor called: Value of i: 10
    B's Constructor called
*/

If class A had both default and parameterized constructors, then Initializer List is not must if we want to initialize “a” using default constructor, but it is must to initialize “a” using parameterized constructor.

4) For initialization of base class members : Like point 3, parameterized constructor of base class can only be called using Initializer List.
#include <iostream>
using namespace std;
 
class A {
    int i;
public:
    A(int );
};
 
A::A(int arg) {
    i = arg;
    cout << "A's Constructor called: Value of i: " << i << endl;
}
 
// Class B is derived from A
class B: A {
public:
    B(int );
};
 
B::B(int x):A(x) { //Initializer list must be used
    cout << "B's Constructor called";
}
 
int main() {
    B obj(10);
    return 0;
}

5) When constructor’s parameter name is same as data member
If constructor’s parameter name is same as data member name then the data member must be initialized either using this pointer or Initializer List. In the following example, both member name and parameter name for A() is “i”.
#include <iostream>
using namespace std;
 
class A {
    int i;
public:
    A(int );
    int getI() const { return i; }
};
 
A::A(int i):i(i) { }  // Either Initializer list or this pointer must be used
/* The above constructor can also be written as 
A::A(int i) { 
    this->i = i;
}
*/
 
int main() {
    A a(10);
    cout<<a.getI();
    return 0;
}
/* OUTPUT:
    10
*/

6) For Performance reasons:
It is better to initialize all class variables in Initializer List instead of assigning values inside body. Consider the following example:
// Without Initializer List
class MyClass {
    Type variable;
public:
    MyClass(Type a) {  // Assume that Type is an already
                     // declared class and it has appropriate 
                     // constructors and operators
      variable = a;
    }
};

Run on IDE
Here compiler follows following steps to create an object of type MyClass
1. Type’s constructor is called first for “a”.
2. The assignment operator of “Type” is called inside body of MyClass() constructor to assign
	variable = a; 
3. And then finally destructor of “Type” is called for “a” since it goes out of scope.
Now consider the same code with MyClass() constructor with Initializer List
// With Initializer List
class MyClass {
    Type variable;
public:
    MyClass(Type a):variable(a) {   // Assume that Type is an already
                     // declared class and it has appropriate
                     // constructors and operators
    }
};

Run on IDE
With the Initializer List, following steps are followed by compiler:
1. Copy constructor of “Type” class is called to initialize : variable(a). The arguments in initializer list are used to copy construct “variable” directly.
2. Destructor of “Type” is called for “a” since it goes out of scope.
As we can see from this example if we use assignment inside constructor body there are three function calls: constructor + destructor + one addition assignment operator call. And if we use Initializer List there are only two function calls: copy constructor + destructor call. See this post for a running example on this point.



Add complex numbers
#include<iostream>
#include<conio.h>

using namespace std;


class Complex
{
private:
	double r,i;

public:
	void input();
	void display();

	Complex add(Complex ob2);

};


void Complex::input()
{
	cout<<"enter the real part"<<endl;
	cin>>r;

	cout<<"enter the imaginary part"<<endl;
	cin>>i;
}

void Complex::display()
{
	cout<<r;

	cout<<"+"<<i<<"i"<<endl;
}

Complex Complex::add(Complex ob2)
{
	Complex  temp;
	temp.r=r+ob2.r;
	temp.i=i+ob2.i;

	return temp;
}

void main()
{
	Complex x;
	x.input();

	Complex y;
	y.input();

	Complex z;
	z=x.add(y);

	x.display();

	y.display();

	z.display();
	getch();

}

OVERLOADED MEMEBR FUNCTIONS:
Function overloading is a feature in C++ where two or more functions can have the same name but different parameters.
Function overloading can be considered as an example of polymorphism feature in C++.
Following is a simple C++ example to demonstrate function overloading.
#include <iostream>
using namespace std;
 
void print(int i) {
  cout << " Here is int " << i << endl;
}
void print(double  f) {
  cout << " Here is float " << f << endl;
}
void print(char* c) {
  cout << " Here is char* " << c << endl;
}
 
int main() {
  print(10);
  print(10.10);
  print("ten");
  return 0;
}




Functions that cannot be overloaded in C++
1) Function declarations that differ only in the return type. For example, the following program fails in compilation.
#include<iostream>
#include<conio.h>

using namespace std;

class X
{
	int a;
	float b;

public:
	int Geta();
	float Geta();  //canot overload functions distinguished by only return type
};

2) Member function declarations with the same name and the name parameter-type-list cannot be overloaded if any of them is a static member function declaration. For example, following program fails in compilation.
#include<iostream>
class Test {
   static void fun(int i) {}
   void fun(int i) {}   
};
 
int main()
{
   Test t;
   getchar();
   return 0;
}

3) Parameter declarations that differ only in a pointer * versus an array [] are equivalent. That is, the array declaration is adjusted to become a pointer declaration. Only the second and subsequent array dimensions are significant in parameter types. For example, following two function declarations are equivalent.
int fun(int *ptr);
int fun(int ptr[]); // redeclaration of fun(int *ptr)

4) Parameter declarations that differ only in that one is a function type and the other is a pointer to the same function type are equivalent.
void h(int ());
void h(int (*)()); // redeclaration of h(int())


5) Parameter declarations that differ only in the presence or absence of const and/or volatile are equivalent. That is, the const and volatile type-specifiers for each parameter type are ignored when determining which function is being declared, defined, or called. For example, following program fails in compilation with error “redefinition of `int f(int)’ “
Example:
#include<iostream>
#include<stdio.h>
  
using namespace std;
  
int f ( int x) {
    return x+10;
}
 
int f ( const int x) {
    return x+10;
}
 
int main() {     
  getchar();
  return 0;
}


Error;     c:\c++learn\projects\project\project\new.cpp(6) : see previous definition of 'f'
6) Two parameter declarations that differ only in their default arguments are equivalent. For example, following program fails in compilation with error “redefinition of `int f(int, int)’ “
#include<iostream>
#include<stdio.h>
  
using namespace std;
  
int f ( int x, int y) {
    return x+10;
}
 
int f ( int x, int y = 10) {
    return x+y;
}
 
int main() {     
  getchar();
  return 0;
}

All above points can be summerised in a below pgm
#include<iostream>
#include<conio.h>

using namespace std;

class X
{
private:
	int a;

public:
	int foo();
	double foo();  //functions differ in only return type

	int foo(int a);
	const int foo(int a);  //functions having same name,para list and one of them is static

	int foo(int *ptr);
	int foo(int ptr[]);//functions tht differ only in pointer and array

	int foo(int a);
	int foo(const int a);//functions having same name and same parametrs one of which is constant

	int foo(int x,int y=8);
	int foo(int x,int y);//functions differ in deafult arguments


};

Default values for formal parameters of a function
The parameters having no default values should be provided from the leftmost argument.
Default values must be provided from the rightmost argument.
Its better to specify the default values only in function prototype even though default values can be provided in the definition also.

Add(int a,int b=10,int c=20)   //correct

Add(int a,int b=10,int c)    //wrong error

#include<iostream>
#include<conio.h>

using namespace std;


class X
{
private:
	int x;

public:
	void Setx(int a,int b=20,int c=10);
	int Getx();
};

void X::Setx(int a,int b,int c)
{
	x=a+b+c;
}

int X::Getx()
{
	return x;
}

int main()
{
	X obj;
	obj.Setx(2,5);
	cout<<"value of x is"<<obj.Getx()<<endl;
	return 0;
}
Output is :2+5+10=17




Constant Member Functions:
The const Member Functions. The member functions of a class can also be declared as constant using const keyword. The constant functions cannot modify any data in the class. The const keyword is suffixed to the function prototype as well as in function definition. 

A function becomes const when const keyword is used in function’s declaration. The idea of const functions is not allow them to modify the object on which they are called. 
It is recommended practice to make as many functions const as possible so that accidental changes to objects are avoided.

#include<iostream>
using namespace std;

class X
{
private:
	int a;
public:
	void increment()const;
};


void X::increment()const
{
	a++;//error  //const function cannot modify data memeber
}


When a function is declared as const, it can be called on any type of object.
 Non-const functions can only be called by non-const objects. 

As seen from following example constant objects cannot call non costant functions.
#include<iostream>
using namespace std;
 
class Test {
    int value;
public:
    Test(int v = 0) {value = v;}
    int getValue() {return value;}
};
 
int main() {
    const Test t;
    cout << t.getValue();
    return 0;
}

Rules of Engagement
const member functions may be invoked for const and non-const objects.
non-const member functions can only be invoked for non-const objects.
If a non-const member function is invoked on a const object, it is a compiler error.
non-const objects may be used for const and non-const parameters
const objects may only be used for const parameters
const methods cannot invoke non-const methods
The Importance of being const
It protects the class user by not allowing him to attempt to modify const objects.
It protects you (the implementer) from inadvertently changing your object.
It provides a clearer definition of the object's interface.Mutable data member:
Mutable Data Members (C++) This keyword can only be applied to non-static and non-const data members of a class. 
If a data member is declared mutable , then it is legal to assign a value to this data member from a const member function.
#include<iostream>
using namespace std;

class X
{
private:
	int a;
	mutable int b;

public:
	void Geta()const;

};

void X::Geta()const
{
	a++;  //error becoz its not mutable
	b++;//fine becoz its mutable
}

Objects and arrays (Array of objects and arrays inside the objects):

#include<iostream>
#include<conio.h>

using namespace std;

class Student
{
private:
	char USN[10];
	char name[10];

public:
	void read();
	void Display();
};

void Student::read()
{
	cin>>USN>>name;
}

void Student::Display()
{
	cout<<USN<<name;
}

void main()
{
	Student a[10];
	int n;

	cout<<"enter the number of students"<<endl;
	cin>>n;

	for(int i=0;i<n;i++)
	{
		cout<<"enter the USN and name"<<endl;
		a[i].read();
	}

	cout<<"the USN and name are"<<endl;
	for(int i=0;i<n;i++)
	{		
		a[i].Display();
	}
}




ARRAYS:
An array is a series of elements of the same type placed in contiguous memory locations that can be individually referenced by adding an index to a unique identifier.

For example, an array containing 5 integer values of type int called foo could be represented as:

 
where each blank panel represents an element of the array. In this case, these are values of type int. These elements are numbered from 0 to 4, being 0 the first and 4 the last; In C++, the first element in an array is always numbered with a zero (not a one), no matter its length.

Like a regular variable, an array must be declared before it is used. A typical declaration for an array in C++ is:

type name [elements];
where type is a valid type (such as int, float...), name is a valid identifier and the elements field (which is always enclosed in square brackets []), specifies the length of the array in terms of the number of elements.

Therefore, the foo array, with five elements of type int, can be declared as:
 
int foo [5];

 
Initializing arrays
 But the elements in an array can be explicitly initialized to specific values when it is declared, by enclosing those initial values in braces {}. For example:
 
int foo [5] = { 16, 2, 77, 40, 12071 }; 


The number of values between braces {} shall not be greater than the number of elements in the array. For example, in the example above, foo was declared having 5 elements (as specified by the number enclosed in square brackets, []), and the braces {} contained exactly 5 values, one for each element. If declared with less, the remaining elements are set to their default values (which for fundamental types, means they are filled with zeroes). For example:


 
int bar [5] = { 10, 20, 30 }; 





Will create an array like this:

 
#include<iostream>
#include<conio.h>

using namespace std;

int main()
{
	int array[5]={1,2,3};

	cout<<array[3]<<endl;

	return 0;
}
Output:0


If elements in intilization list are more than the size of array

#include<iostream>
#include<conio.h>

using namespace std;

int main()
{
	int array[5]={1,2,3,4,5,6}; //error too many initialize values

	cout<<array[3]<<endl;

	return 0;
}

The initializer can even have no values, just the braces:


 
int baz [5] = { }; 





This creates an array of five int values, each initialized with a value of zero:


When an initialization of values is provided for an array, C++ allows the possibility of leaving the square brackets empty []. In this case, the compiler will assume automatically a size for the array that matches the number of values included between the braces {}:
 
int foo [] = { 16, 2, 77, 40, 12071 };

Finally, the evolution of C++ has led to the adoption of universal initialization also for arrays. Therefore, there is no longer need for the equal sign between the declaration and the initializer. Both these statements are equivalent:
1
2
int foo[] = { 10, 20, 30 };
int foo[] { 10, 20, 30 }; 


Accessing the values of an array

1
2
int foo[5];         // declaration of a new array
foo[2] = 75;        // access to an element of the array.  




Arrays as parameters

At some point, we may need to pass an array to a function as a parameter. In C++, it is not possible to pass the entire block of memory represented by an array to a function directly as an argument. But what can be passed instead is its address. In practice, this has almost the same effect, and it is a much faster and more efficient operation.

To accept an array as parameter for a function, the parameters can be declared as the array type, but with empty brackets, omitting the actual size of the array. For example:
 
void procedure (int arg[])





This function accepts a parameter of type "array of int" called arg. In order to pass to this function an array declared as:
 
int myarray [40];





it would be enough to write a call like this:
 
procedure (myarray);



Here you have a complete example: 


1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
// arrays as parameters
#include <iostream>
using namespace std;

void printarray (int arg[], int length) {
  for (int n=0; n<length; ++n)
    cout << arg[n] << ' ';
  cout << '\n';
}

int main ()
{
  int firstarray[] = {5, 10, 15};
  int secondarray[] = {2, 4, 6, 8, 10};
  printarray (firstarray,3);
  printarray (secondarray,5);
}
5 10 15
2 4 6 8 10


















































Operator Overloading:
In C++, operators are implemented as functions. By using function overloading on the operator functions, you can define your own versions of the operators that work with different data types (including classes that you’ve written). Using function overloading to overload operators is called operator overloading.

Types of operators which can be overloaded
1.Unary operator s ex:++,--,+,-etc
2.Binary operator ex:+,-,/,*,<>=etc
3.new ,delete operators
4.special operators ex(),[],->
5.comma operator ,


1.Overloading of Binary operator + using member function. Refer notes for explanation
#include<iostream>
#include<conio.h>

using namespace std;

class Complex
{
private:
	int x,y;

public:
	void SetData(int a ,int b)
	{
		x=a;
		y=b;
	}

	void display()
	{
		cout<<"value of real part is"<<x<<endl;
		cout<<"value of imag part is"<<y<<endl;
	}
	Complex operator+(Complex C)  //c1 calls operator+ functions passing c2 as argument
	{
		Complex temp;
		temp.x=x +C.x;
                          c1 ka x(caller functions x value).
                              C2 ka x value
		temp.y=y+C.y;

		return temp;

	}
};


int main()
{
	Complex c1,c2,c3;

	c1.SetData(3,5);

	c1.display();

	c2.SetData(6,8);

	c2.display();

	c3=c1+c2;

	c3.display();

	return 0;
}

Overloading of assignment opearator :
#include<iostream>
#include<conio.h>

using namespace std;

class Complex
{
private:
	int x,y;

public:
	void SetData(int a ,int b)
	{
		x=a;
		y=b;
	}

	void display()
	{
		cout<<"value of real part is"<<x<<endl;
		cout<<"value of imag part is"<<y<<endl;
	}
	void operator=(Complex C)
	{
		x=C.x;
		y=C.y;
	}
};


int main()
{
	Complex c1,c2,c3;

	c1.SetData(3,5);

	c1.display();

	//c2.SetData(6,8);

	//c2.display();

	c2=c1;

	c2.display();

	return 0;
}




//unary – operator

#include<iostream>
#include<conio.h>

using namespace std;

class X
{
private:
	int x,y;

public:
	void SetData(int m,int n)
	{
		x = m;
		y = n;
	}

	void Display()
	{
		cout<<"values are"<<x<<y<<endl;
	}

	X operator-()
	{
		X ob;

		ob.x = -x;
		ob.y = -y;

		return ob;
	}
};

void main()
{
	X x1,x2,x3;

	x1.SetData(5,10);

	x1.Display();

	x2 = -x1;
}

#include<iostream>
#include<conio.h>

//postincrement opeartor overloading
using namespace std;

class X
{
private:
	int a;

public:
	void SetData(int m)
	{
		a = m;
	}

	void Display()
	{
		cout<<"value of a is"<<a<<endl;
	}

	X operator++(int)
	{
		X temp;
		temp.a = a++;
		return temp;
	}
};

void main()
{
	X ob1,ob2;

	ob1.SetData(3);
	ob1.Display();       //3

	ob2 = ob1++;

	ob1.Display();         //4
	ob2.Display();         //3

}
Subscript operator
#include<iostream>
#include<conio.h>

using namespace std;

class X
{
private:
	int a[20];

public:
	X(int n)
	{
		for(int i=0;i<n;i++)
			a[i] = 2*i;
	}

	int operator[](int i)
	{
		return a[i];
	}

	
};


void main()
{
	int n;
	cout<<"enter the n"<<endl;
	cin>>n;

	X ob(n);

for(int j=0;j<n;j++)
	cout<<ob[j]<<endl;

}


SUBSCRIPT OPERATOR:

#include<iostream>
#include<conio.h>

using namespace std;

class Marks
{
private:
	int s[3];

public:
	Marks(int x,int y,int z)
	{
		s[0] = x;
		s[1] = y;
		s[2] = z;
	}

	int operator [](int pos)
	{
		return s[pos];
	}
};


void main()
{
	Marks ob(10,20,30);

	cout<<ob[0]<<endl;

	cout<<ob[1]<<endl;

	cout<<ob[2]<<endl;
}


Operator ->>>>>

Pavan

#include<iostream>
#include<conio.h>

using namespace std;

class Marks
{
private:
	int a;

public:
	Marks(int m=0)
	{
		a = m;
	}

	Marks* operator->()
	{
		return this;
	}

	int Get()
	{
		return a;
	}

	
};


void main()
{
	Marks ob(4);

	cout<<"a is"<<ob->Get()<<endl;
}

#include<iostream>
#include<conio.h>

using namespace std;

class X
{
public:
	int m;
	X* operator->()
	{
		return this;
	}
};


void main()
{
	X ob;

	ob->m = 10;

	cout<<ob->m<<endl;
}


#include<iostream>
#include<conio.h>

//Assignment opeartor  overloading
using namespace std;

class X
{
private:
	int a;

public:
	void SetData(int m)
	{
		a = m;
	}

	void Display()
	{
		cout<<"value of a is"<<a<<endl;
	}

	void operator=(const X &ob)
	{
		a = ob.a;
	}
};

void main()
{
	X ob1,ob2;

	ob1.SetData(3);
	ob1.Display();       //3

	ob2 = ob1;
	ob2.Display();         //3

}
	 




1
2
3
int value = 5;
int *ptr = &value;
*ptr = 6; // change value to 6

However, what happens if value is const?
1
2
3
const int value = 5; // value is const
int *ptr = &value; // compile error: cannot convert const int* to int*
*ptr = 6; // change value to 6

The above snippet won’t compile -- we can’t set a non-const pointer to a const variable. This makes sense: a const variable is one whose value can not be changed. Hypothetically, if we could set a non-const pointer to a const value, then we would be able to dereference the non-const pointer and change the value. That would violate the intention of const.
Pointer to const value
A pointer to a const value is a (non-const) pointer that points to a constant value.
To declare a pointer to a const value, use the const keyword before the data type:
1
2
3
const int value = 5;
const int *ptr = &value; // this is okay, ptr is pointing to a "const int"
*ptr = 6; // not allowed, we can't change a const value

In the above example, ptr points to a const int.
So far, so good, right? Now consider the following example:
1
2
int value = 5; // value is not constant
const int *ptr = &value; // this is still okay

A pointer to a constant variable can point to a non-constant variable (such as variable value in the example above). Think of it this way: a pointer to a constant variable treats the variable as constant when it is accessed through the pointer, regardless of whether the variable was initially defined as const or not.
Thus, the following is okay:
1
2
3
int value = 5;
const int *ptr = &value; // ptr points to a "const int"
value = 6; // the value is non-const when accessed through a non-const identifier

But the following is not:
1
2
3
int value = 5;
const int *ptr = &value; // ptr points to a "const int"
*ptr = 6; // ptr treats its value as const, so changing the value through ptr is not legal

Because a pointer to a const value is not const itself (it just points to a const value), the pointer can be redirected to point at other values:
1
2
3
4
5
int value1 = 5;
const int *ptr = &value1; // ptr points to a const int
 
int value2 = 6;
ptr = &value2; // okay, ptr now points at some other const int

Const pointers
We can also make a pointer itself constant. A const pointer is a pointer whose value can not be changed after initialization
To declare a const pointer, use the const keyword between the asterisk and the pointer name:
1
2
int value = 5;
int *const ptr = &value;

Just like a normal const variable, a const pointer must be initialized to a value upon declaration. This means a const pointer will always point to the same address. In the above case, ptr will always point to the address of value (until ptr goes out of scope and is destroyed).
1
2
3
4
5
int value1 = 5;
int value2 = 6;
 
int * const ptr = &value1; // okay, the const pointer is initialized to the address of value1
ptr = &value2; // not okay, once initialized, a const pointer can not be changed.

However, because the value being pointed to is still non-const, it is possible to change the value being pointed to via dereferencing the const pointer:
1
2
3
int value = 5;
int *const ptr = &value; // ptr will always point to value
*ptr = 6; // allowed, since ptr points to a non-const int

Const pointer to a const value
Finally, it is possible to declare a const pointer to a const value by using the const keyword both before the type and before the variable name:
1
2
int value = 5;
const int *const ptr = &value;

A const pointer to a const value can not be set to point to another address, nor can the value it is pointing to be changed through the pointer.
Recapping
To summarize, you only need to remember 4 rules, and they are pretty logical:
A non-const pointer can be redirected to point to other addresses.
A const pointer always points to the same address, and this address can not be changed.
A pointer to a non-const value can change the value it is pointing to. These can not point to a const value.
A pointer to a const value treats the value as const (even if it is not), and thus can not change the value it is pointing to.
Keeping the declaration syntax straight can be challenging. Just remember that the type of value the pointer points to is always on the far left:
1
2
3
int value = 5;
const int *ptr1 = &value; // ptr1 points to a "const int", so this is a pointer to a const value.
int *const ptr2 = &value; // ptr2 points to an "int", so this is a const pointer to a non-const value.

Conclusion
Pointers to const values are primarily used in function parameters (for example, when passing an array to a function) to help ensure the function doesn’t inadvertently change the passed in argument. We will discuss this further in the section on functions
 
 
6.11 — Reference variables
BY ALEX ON JULY 16TH, 2007 | LAST MODIFIED BY ALEX ON AUGUST 15TH, 2016
So far, we’ve discussed two basic variable types:
Normal variables, which hold values directly.
Pointers, which hold the address of another value (or null) and can be dereferenced to retrieve the value at the address they point to.
References are the third basic type of variable that C++ supports.
References
A reference is a type of C++ variable that acts as an alias to another variable. References are declared by using an ampersand (&) between the reference type and the variable name:
1
2
int value = 5; // normal integer
int &ref = value; // reference to variable value

In this context, the ampersand does not mean “address of”, it means “reference to”.
In most cases, references act identically to the variables they’re referencing. Let’s take a look at references in use:
1
2
3
4
5
6
7
8
int value = 5; // normal integer
int &ref = value; // reference to variable value
value = 6; // value is now 6
ref = 7; // value is now 7
 
cout << value; // prints 7
++ref;
cout << value; // prints 8

This code prints:
7
8
In the above example, ref and value are synonymous.
Using the address-of operator on a reference returns the address of the value being referenced:
1
2
cout << &value; // prints 0012FF7C
cout << &ref; // prints 0012FF7C

References are treated as const
Even though they are not declared using the const keyword, references are treated as being const, meaning that they must be initialized and once initialized can not be reassigned.
1
2
3
4
int value = 5;
int &ref = value; // valid reference
 
int &invalidRef; // invalid, needs to reference something

References must always be initialized with a valid object. Unlike pointers, which can hold a null value, there is no such thing as a null reference.
 
Because references are implicitly const, a reference can not be “redirected” (assigned) to reference another variable. Consider the following snippet:
1
2
3
4
5
int value1 = 5;
int value2 = 6;
 
int &ref = value1; // okay, ref is now an alias for value1
int &ref = value2; // assigns 6 (the value of value2) to value1 -- does NOT change the reference!

Note that the second statement may not do what you might expect! Instead of reassigning ref to alias value2, it instead assigns the value from value2 to value1 (which ref is a reference of).
Even though references are treated as const themselves, you can’t initialize a reference with a const object:
1
2
const int x = 5;
int &ref = x; // invalid, non-const reference to const object

Otherwise, you’d be able to change the value of x through ref, which would violate x’s const-ness. 
 
Reference to const value
Just like it’s possible to declare a pointer to a const value, it’s also possible to declare a reference to a const value. This is done by using the const keyword.
1
2
const int value = 5;
const int &ref = value; // ref is a reference to const value

A reference to a const treats the value it is referencing as const. This means it’s okay to initialize a reference to a const with a const value.
Much like a pointer to a const value, a reference to a const value can reference a non-const variable. When accessed through a reference to a const, the value is considered const even if the original variable is not:
1
2
3
4
5
int value = 5;
const int &ref = value;
 
ref = 6; // illegal -- ref is const
value = 7; // okay, value is non-const

A reference to a const is often called a const reference for short, though this does make for some inconsistent nomenclature with pointers.
 
References as function parameters
Most often, references are used as function parameters because they allow us to pass a parameter to a function without making a copy of the value itself (we just copy the reference).|
In lesson 6.8 -- Pointers and arrays we talked about how passing a pointer argument to a function allows the function to dereference the pointer to modify the argument’s value directly.
References work similarly in this regard. A function that uses a reference parameter is able to modify the argument passed in:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
#include <iostream>
 
// ref is a reference to the argument passed in, not a copy
void changeN(int &ref)
{
	ref = 6;
}
 
int main()
{
	int n = 5;
 
	std::cout << n << '\n';
 
	changeN(n); // note that this is a non-reference argument
 
	std::cout << n << '\n';
	return 0;
}

This program prints:
5
6
When argument n is passed to the function, the function parameter ref is set as a reference to argument n. This allows the function to change the value of n through ref! Note that n does not need to be a reference itself.
This is useful both when the function needs to change the value of an argument passed in, or when making a copy of the argument would be expensive (e.g. for a large struct).
References as function parameters can also be const. This allows us to access the argument without making a copy of it, while guaranteeing that the function will not change the value being referenced.
1
2
3
4
5
// ref is a const reference to the argument passed in, not a copy
void changeN(const int &ref)
{
	ref = 6; // not allowed, ref is const
}

To avoid making unnecessary, potentially expensive copies, variables that are not pointers and not fundamental data types (int, double, etc…) should be generally passed by (const) reference.
Rule: Pass non-pointer, non-fundamental data type variables by (const) reference.
We’ll talk about reference parameters in more detail in the next chapter (on functions).
 
 
References as shortcuts
A secondary use of references is to provide easier access to nested data. Consider the following struct:
1
2
3
4
5
6
7
8
9
10
11
12
13
struct Something
{
    int value1;
    float value2;
};
 
struct Other
{
    Something something;
    int otherValue;
};
 
Other other;

Let’s say we needed to work with the value1 field of the Something struct of other. Normally, we’d access that member as other.something.value1. If there are many separate accesses to this member, the code can become messy. References allow you to more easily access the member:
1
2
int &ref = other.something.value1;
// ref can now be used in place of other.something.value1

The following two statements are thus identical:
1
2
other.something.value1 = 5;
ref = 5;

This can help keep your code cleaner and more readable.
Const references to literal values
You can assign const references to literal values, though there is typically not much need to do so directly:
1
const int &rnRef = 6;

More often this is useful when using const references as function parameters, because a const reference parameter allows you to pass in a non-const argument, a const argument, or a literal:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
#include <iostream>
 
void printIt(const int &x)
{
    std::cout << x;
}
 
int main()
{
    int a = 1;
    printIt(a);
 
    const int b = 2;
    printIt(b);
 
    printIt(3);
 
    return 0;
}

The above prints
123
As you would expect.
References vs pointers
References and pointers have an interesting relationship -- a reference acts like a const pointer that is implicitly dereferenced when accessed. Thus given the following:
1
2
3
int value = 5;
int *const ptr = &value;
int &ref = value;

*ptr and ref evaluate identically. As a result, the following two statements produce the same effect:
1
2
*ptr = 5;
ref = 5;

Similarly, a const reference acts just like a const pointer to a const value that is implicitly dereferenced.
Because references must be initialized to valid objects and can not be changed once set, references are generally much safer to use than pointers. However, they are also a bit more limited in functionality.
If a given task can be solved with either a reference or a pointer, the reference should generally be preferred. Pointers should only be used in situations where references are not sufficient (such as dynamically allocating memory).
6.13 — Void pointers
BY ALEX ON JULY 19TH, 2007 | LAST MODIFIED BY ALEX ON MAY 24TH, 2016
The void pointer, also known as the generic pointer, is a special type of pointer that can be pointed at objects of any data type! A void pointer is declared like a normal pointer, using the void keyword as the pointer’s type:
1
void *ptr; // ptr is a void pointer

A void pointer can point to objects of any data type:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
int nValue;
float fValue;
 
struct Something
{
    int n;
    float f;
};
 
Something sValue;
 
void *ptr;
ptr = &nValue; // valid
ptr = &fValue; // valid
ptr = &sValue; // valid

However, because the void pointer does not know what type of object it is pointing to, it cannot be dereferenced directly! Rather, the void pointer must first be explicitly cast to another pointer type before it is dereferenced.
1
2
3
4
5
6
7
8
int value = 5;
void *voidPtr = &value;
 
//cout << *voidPtr << endl; // illegal: cannot dereference a void pointer
 
int *intPtr = static_cast<int*>(voidPtr); // however, if we cast our void pointer to an int pointer...
 
cout << *intPtr << endl; // then we can dereference it like normal

This prints:
5
The next obvious questions is: If a void pointer doesn’t know what it’s pointing to, how do we know what to cast it to? Ultimately, that is up to you to keep track of.
Here’s an example of a void pointer in use:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
#include <iostream>
 
enum Type
{
    INT,
    FLOAT,
    CSTRING
};
 
void printValue(void *ptr, Type type)
{
    switch (type)
    {
        case INT:
            std::cout << *static_cast<int*>(ptr) << '\n'; // cast to int pointer and dereference
            break;
        case FLOAT:
            std::cout << *static_cast<float*>(ptr) << '\n'; // cast to float pointer and dereference
            break;
        case CSTRING:
            std::cout << static_cast<char*>(ptr) << '\n'; // cast to char pointer and dereference
            break;
    }
}
 
int main()
{
    int nValue = 5;
    float fValue = 7.5;
    char szValue[] = "Mollie";
 
    printValue(&nValue, INT);
    printValue(&fValue, FLOAT);
    printValue(szValue, CSTRING);
 
    return 0;
}

This program prints:
5
7.5
Mollie
Void pointer miscellany
Void pointers can be set to a null value:
1
void *ptr = 0; // ptr is a void pointer that is currently a null pointer

Although some compilers allow deleting a void pointer that points to dynamically allocated memory, doing so should be avoided, as it can result in undefined behavior.
It is not possible to do pointer arithmetic on a void pointer. This is because pointer arithmetic requires the pointer to know what size object it is pointing to, so it can increment or decrement the pointer appropriately.
Note that there is no such thing as a void reference. This is because a void reference would be of type void &, and would not know what type of value it referenced.
Conclusion
In general, it is a good idea to avoid using void pointers unless absolutely necessary, as they effectively allow you to avoid type checking. This allows you to inadvertently do things that make no sense, and the compiler won’t complain about it. For example, the following would be valid:
1
2
    int nValue = 5;
    printValue(&nValue, CSTRING);

But who knows what the result would actually be!
Although the above function seems like a neat way to make a single function handle multiple data types, C++ actually offers a much better way to do the same thing (via function overloading) that retains type checking to help prevent misuse. Many other places where void pointers would once be used to handle multiple data types are now better done using templates, which also offer strong type checking.
However, very occasionally, you may still find a reasonable use for the void pointer. Just make sure there isn’t a better (safer) way to do the same thing using other language mechanisms first!
 
 
 
 
 
 
 
 
 
 
 
 
 
 
PASS BY REFERENCE

#include<iostream>
#include<conio.h>


using namespace std;

void swap(int &x,int &y)
{
	int  swap;

	swap=x;
	x=y;
	y=swap;

}
int main()
{
int a , b,temp;

cout<<"enterthe value of a"<<endl;
cin>>a;

cout<<"enter the value of b"<<endl;
cin>>b;

swap(a,b);

cout<<" a is"<<a<<endl;

cout<<"b is"<<b<<endl;

return 0;
}

Input a=10  b=20      OUTPUT  a=20 a=10


#include<iostream>
#include<conio.h>


using namespace std;

void swap(int *x,int *y)
{
	int  swap;

	swap=*x;
	*x=*y;
	*y=swap;

}
int main()
{
int a=10 , b=20,temp;

swap(&a,&b);

cout<<" a is"<<a<<endl;

cout<<"b is"<<b<<endl;

return 0;
}

OUTPUT  a=20 b=10


Pass by value

Summary
Advantages of passing by value:
Arguments passed by value can be variables (e.g. x), literals (e.g. 6), expressions (e.g. x+1), structs & classes, and enumerators.
Arguments are never changed by the function being called, which prevents side effects.
Disadvantages of passing by value:
Copying structs and classes can incur a significant performance penalty, especially if the function is called many times.
When to use pass by value:
When passing fundamental data type and enumerators.
When not to use pass by value:
When passing arrays, structs, or classes.
In most cases, pass by value is the best way to pass arguments to functions -- it is flexible and safe.

 #include<iostream>
#include<conio.h>


using namespace std;

void swap(int x,int y)
{
	int  swap;

	swap=x;
	x=y;
	y=swap;

}
int main()
{
int a=10 , b=20,temp;

swap(a,b);

cout<<" a is"<<a<<endl;

cout<<"b is"<<b<<endl;

return 0;
}
 
OUTPUT a=10,b=20
 
7.3 — Passing arguments by reference
BY ALEX ON JULY 24TH, 2007 | LAST MODIFIED BY ALEX ON APRIL 17TH, 2016
While pass by value is suitable in many cases, it has a couple of limitations. 
First, when passing a large struct or class to a function, pass by value will make a copy of the argument into the function parameter. In many cases, this is a needless performance hit, as the original argument would have sufficed. 
Second, when passing arguments by value, the only way to return a value back to the caller is via the function’s return value. While this is often suitable, there are cases where it would be more clear and efficient to have the function modify the argument passed in. Pass by reference solves both of these issues.
Pass by reference
To pass a variable by reference, we simply declare the function parameters as references rather than as normal variables:
1
2
3
4
void addOne(int &y) // y is a reference variable
{
    y = y + 1;
}

When the function is called, y will become a reference to the argument. Since a reference to a variable is treated exactly the same as the variable itself, any changes made to the reference are passed through to the argument!
The following example shows this in action:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
void foo(int &value)
{
    value = 6;
}
 
int main()
{
    int value = 5;
 
    cout << "value = " << value << '\n';
    foo(value);
    cout << "value = " << value << '\n';
    return 0;
}

This program is the same as the one we used for the pass by value example, except foo’s parameter is now a reference instead of a normal variable. When we call foo(x), y becomes a reference to x. This snippet produces the output:
value = 5
value = 6
As you can see, the function changed the value of the argument from 5 to 6!
Here’s another example:
1
2
3
4
5
6
7
8
9
10
11
12
13
void addOne(int &y) // y is a reference variable
{
    y = y + 1;
} // y is destroyed here
 
int main()
{
    int x = 5;
    std::cout << "x = " << x << '\n';
    addOne(x);
    std::cout << "x = " << x << '\n';
    return 0;
}

This produces the output:
x = 5
x = 6
Note that the value of argument x was changed by the function.
Returning multiple values via out parameters
Sometimes we need a function to return multiple values. However, functions can only have one return value. One way to return multiple values is using reference parameters:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
#include <iostream>
#include <math.h>    // for sin() and cos()
 
void getSinCos(double degrees, double &sinOut, double &cosOut)
{
    // sin() and cos() take radians, not degrees, so we need to convert
    static const double pi = 3.14159265358979323846; // the value of pi
    double radians = degrees * pi / 180.0;
    sinOut = sin(radians);
    cosOut = cos(radians);
}
 
int main()
{
    double sin(0.0);
    double cos(0.0);
 
    // getSinCos will return the sin and cos in variables sin and cos
    getSinCos(30.0, sin, cos);
 
    std::cout << "The sin is " << sin << '\n';
    std::cout << "The cos is " << cos << '\n';
    return 0;
}

This function takes one parameter (by value) as input, and “returns” two parameters (by reference) as output. Parameters that are only used for returning values back to the caller are called out parameters. We’ve named these out parameters with the suffix “out” to denote that they’re out parameters. This helps remind the caller that the initial value passed to these parameters doesn’t matter, and that we should expect them to be rewritten.
Pass by const reference
As mentioned in the introduction, one of the major disadvantages of pass by value is that all arguments passed by value are copied into the function parameters. When the arguments are large structs or classes, this can take a lot of time. References provide a way to avoid this penalty. When an argument is passed by reference, a reference is created to the actual argument (which takes minimal time) and no copying of values takes place. This allows us to pass large structs and classes with a minimum performance penalty.
However, this also opens us up to potential trouble. References allow the function to change the value of the argument, which is undesirable when we want an argument be read-only. 
If we know that a function should not change the value of an argument, but don’t want to pass by value, the best solution is to pass by const reference.
You already know that a const reference is a reference that does not allow the variable being referenced to be changed through the reference. Consequently, if we use a const reference as a parameter, we guarantee to the caller that the function will not change the argument!
The following function will produce a compiler error:
1
2
3
4
void foo(const int &x) // x is a const reference
{
    x = 6;  // compile error: a const reference cannot have its value changed!
}

Using const is useful for several reasons:
It enlists the compilers help in ensuring values that shouldn’t be changed aren’t changed (the compiler will throw an error if you try, like in the above example).
It tells the programmer that the function won’t change the value of the argument. This can help with debugging.
You can’t pass a const argument to a non-const reference parameter. Using const parameters ensures you can pass both non-const and const arguments to the function.
Rule: When passing an argument by reference, always use a const references unless you need to change the value of the argument
Summary
Advantages of passing by reference:
It allows a function to change the value of the argument, which is sometimes useful. Otherwise, const references can be used to guarantee the function won’t change the argument.
Because a copy of the argument is not made, it is fast, even when used with large structs or classes.
References can be used to return multiple values from a function.
References must be initialized, so there’s no worry about null values.
Disadvantages of passing by reference:
Because a non-const reference cannot be made to an rvalue (e.g. a literal or an expression), reference arguments must be normal variables.
It can be hard to tell whether a parameter passed by non-const reference is meant to be input, output, or both. Judicious use of const and a naming suffix for out variables can help.
It’s impossible to tell from the function call whether the argument may change. An argument passed by value and passed by reference looks the same. We can only tell whether an argument is passed by value or reference by looking at the function declaration. This can lead to situations where the programmer does not realize a function will change the value of the argument.
When to use pass by reference:
When passing structs or classes (use const if read-only).
When you need the function to modify an argument.
When not to use pass by reference:
When passing fundamental types (use pass by value).
 
 
 
 
 
7.4 — Passing arguments by address
BY ALEX ON JULY 25TH, 2007 | LAST MODIFIED BY ALEX ON SEPTEMBER 12TH, 2016
There is one more way to pass variables to functions, and that is by address. Passing an argument by address involves passing the address of the argument variable rather than the argument variable itself. 
Because the argument is an address, the function parameter must be a pointer. The function can then dereference the pointer to access or change the value being pointed to.
Here is an example of a function that takes a parameter passed by address:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
#include <iostream>
 
void foo(int *ptr)
{
    *ptr = 6;
}
 
int main()
{
    int value = 5;
 
    std::cout << "value = " << value << '\n';
    foo(&value);
    std::cout << "value = " << value << '\n';
    return 0;
}

The above snippet prints:
value = 5
value = 6
As you can see, the function foo() changed the value of the argument (variable value) through pointer parameter ptr.
Pass by address is typically used with arrays and dynamically allocated variables. For example, the following function will print all the values in an array:
1
2
3
4
5
void printArray(int *array, int length)
{
    for (int index=0; index < length; ++index)
        std::cout << array[index] << ' ';
}

Here is an example program that calls this function:
1
2
3
4
5
int main()
{
    int array[6] = { 6, 5, 4, 3, 2, 1 }; // remember, arrays decay into pointers
    printArray(array, 6); // so array evaluates to a pointer to the first element of the array here, no & needed
}

This program prints the following:
6 5 4 3 2 1
 
 
Remember that fixed arrays decay into pointers when passed to a function, so we have to pass the length as a separate parameter.
It is always a good idea to ensure parameters passed by address are not null pointers before dereferencing them. Dereferencing a null pointer will typically cause the program to crash. Here is our printArray() function with a null pointer check:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
void printArray(int *array, int length)
{
    // if user passed in a null pointer for array, bail out early!
    if (!array)
        return;
 
    for (int index=0; index < length; ++index)
        cout << array[index] << ' ';
}
 
int main()
{
    int array[6] = { 6, 5, 4, 3, 2, 1 };
    printArray(array, 6);
}

Passing by const address
Because printArray() doesn’t modify any of its arguments, it’s good form to make the array parameter const:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
void printArray(const int *array, int length)
{
    // if user passed in a null pointer for array, bail out early!
    if (!array)
        return;
 
    for (int index=0; index < length; ++index)
        std::cout << array[index] << ' ';
}
 
int main()
{
    int array[6] = { 6, 5, 4, 3, 2, 1 };
    printArray(array, 6);
}

This allows us to tell at a glance that printArray() won’t modify the array argument passed in, and will ensure we don’t do so by accident.
Addresses are actually passed by value
When you pass a pointer to a function by address, the pointer’s value (the address it points to) is copied from the argument to the function’s parameter. In other words, it’s passed by value! If you change the function parameter’s value, you are only changing a copy. Consequently, the original pointer argument will not be changed.
Here’s a sample program that illustrates this.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
#include <iostream>
 
void setToNull(int *tempPtr)
{
    // we're making tempPtr point at something else, not changing the value that tempPtr points to.
    tempPtr = nullptr; // use 0 instead if not C++11
}
 
int main()
{ 
    // First we set ptr to the address of five, which means *ptr = 5
    int five = 5;
    int *ptr = &five;
	
    // This will print 5
    std::cout << *ptr;
 
    // tempPtr will receive a copy of ptr
    setToNull(ptr);
 
    // ptr is still set to the address of five!
 
    // This will print 5
    if (ptr)
        std::cout << *ptr;
    else
        std::cout << " ptr is null";
 
    return 0;
}

tempPtr receives a copy of the address that ptr is holding. Even though we change tempPtr to point at something else (nullptr), this does not change the value that ptr points to. Consequently, this program prints:
55
Note that even though the address itself is passed by value, you can still dereference that address to change the argument’s value. This is a common point of confusion, so let’s clarify:
When passing an argument by address, the function parameter variable receives a copy of the address from the argument. At this point, the function parameter and the argument both point to the same value.
If the function parameter is then dereferenced to change the value being pointed to, that will impact the value the argument is pointing to, since both the function parameter and argument are pointing to the same value!
If the function parameter is assigned a different address, that will not impact the argument, since the function parameter is a copy, and changing the copy won’t impact the original. After changing the function parameter’s address, the function parameter and argument will point to different values, so dereferencing the parameter and changing the value will no longer affect the value pointed to by the argument.
The following program illustrates the point:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
#include <iostream>
 
void setToSix(int *tempPtr)
{
    *tempPtr = 6; // we're changing the value that tempPtr (and ptr) points to
}
 
int main()
{ 
    // First we set ptr to the address of five, which means *ptr = 5
    int five = 5;
    int *ptr = &five;
	
    // This will print 5
    std::cout << *ptr;
 
    // tempPtr will receive a copy of ptr
    setToSix(ptr);
 
    // tempPtr changed the value being pointed to to 6, so ptr is now pointing to the value 6
 
    // This will print 6
    if (ptr)
        std::cout << *ptr;
    else
        std::cout << " ptr is null";
 
    return 0;
}

This prints:
56
Passing addresses by reference
The next logical question is, “What if we want to change the address an argument points to from within the function?”. Turns out, this is surprisingly easy. You can simply pass the address by reference. The syntax for doing a reference to a pointer is a little strange (and easy to get backwards). However, if you do get it backwards, the compiler will give you an error.
The following program illustrates using a reference to a pointer:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
#include <iostream>
 
// tempPtr is now a reference to a pointer, so any changes made to tempPtr will change the argument as well!
void setToNull(int *&tempPtr)
{
    tempPtr = nullptr; // use 0 instead if not C++11
}
 
int main()
{ 
    // First we set ptr to the address of five, which means *ptr = 5
    int five = 5;
    int *ptr = &five;
	
    // This will print 5
    std::cout << *ptr;
 
    // tempPtr is set as a reference to ptr
    setToNull(ptr);
 
    // ptr has now been changed to nullptr!
 
    if (ptr)
        std::cout << *ptr;
    else
        std::cout << " ptr is null";
 
    return 0;
}

When we run the program again with this version of the function, we get:
5 ptr is null
Which shows that calling setToNull() did indeed change the value of ptr from &five to nullptr!
There is only pass by value
Now that you understand the basic differences between passing by reference, address, and value, let’s get reductionist for a moment. 🙂
In the lesson on passing arguments by reference, we briefly mentioned that references are typically implemented by the compiler as pointers. This means that behind the scenes, pass by reference is essentially just a pass by address (with access to the reference doing an implicit dereference).
And just above, we showed that pass by address is actually just passing an address by value!
Therefore, we can conclude that C++ really passes everything by value! The properties of pass by address (and reference) comes solely from the fact that we can dereference the passed address to change the argument, which we can not do with a normal value parameter!
Summary
Advantages of passing by address:
It allows a function to change the value of the argument, which is sometimes useful. Otherwise, const can be used to guarantee the function won’t change the argument.
Because a copy of the argument is not made, it is fast, even when used with large structs or classes.
We can return multiple values from a function.
Disadvantages of passing by address:
Because literals and expressions do not have addresses, pointer arguments must be normal variables.
All values must be checked to see whether they are null. Trying to dereference a null value will result in a crash. It is easy to forget to do this.
Because dereferencing a pointer is slower than accessing a value directly, accessing arguments passed by address is slower than accessing arguments passed by value.
When to use pass by address:
When passing pointer values.
When passing built-in arrays (if you’re okay with the fact that they’ll decay into a pointer).
When not to use pass by address:
When passing structs or classes (use pass by reference).
When passing fundamental types (use pass by value).
As you can see, pass by address and pass by reference have almost identical advantages and disadvantages. Because pass by reference is generally safer than pass by address, pass by reference should be preferred in most cases.
Rule: Prefer pass by reference to pass by address whenever applicable.



7.4a — Returning values by value, reference, and address
BY ALEX ON FEBRUARY 25TH, 2008 | LAST MODIFIED BY ALEX ON NOVEMBER 18TH, 2016
In the three previous lessons, you learned about passing arguments to functions by value, reference, and address. In this section, we’ll consider the issue of returning values back to the caller via all three methods.
As it turns out, returning values from a function to its caller by value, address, or reference works almost exactly the same way as passing parameters to a function does. All of the same upsides and downsides for each method are present. The primary difference between the two is simply that the direction of data flow is reversed. However, there is one more added bit of complexity -- because local variables in a function go out of scope and are destroyed when the function returns, we need to consider the effect of this on each return type.
Return by value
Return by value is the simplest and safest return type to use. When a value is returned by value, a copy of that value is returned to the caller. As with pass by value, you can return by value literals (eg. 5), variables (eg. x), or expressions (eg. x+1), which makes return by value very flexible.
Another advantage of return by value is that you can return variables (or expressions) that involve local variables declared within the function without having to worry about scoping issues. Because the variables are evaluated before the function returns, and a copy of the value is returned to the caller, there are no problems when the function’s variable goes out of scope at the end of the function.
1
2
3
4
5
int doubleValue(int x)
{
    int value = x * 2;
    return value ; // A copy of value will be returned here
} // value goes out of scope here

Return by value is the most appropriate when returning variables that were declared inside the function, or for returning function arguments that were passed by value. However, like pass by value, return by value is slow for structs and large classes.
When to use return by value:
When returning variables that were declared inside the function
When returning function arguments that were passed by value
When not to use return by value:
When returning a built-in array or pointer (use return by address)
When returning a large struct or class (use return by reference)
Return by address
Returning by address involves returning the address of a variable to the caller. Similar to pass by address, return by address can only return the address of a variable, not a literal or an expression (which don’t have addresses). Because return by address just copies an address from the function to the caller, return by address is fast.
However, return by address has one additional downside that return by value doesn’t -- if you try to return the address of a variable local to the function, your program will exhibit undefined behavior. Consider the following example:
1
2
3
4
5
int* doubleValue(int x)
{
    int value = x * 2;
    return &value; // return value by address here
} // value destroyed here

As you can see here, value is destroyed just after its address is returned to the caller. The end result is that the caller ends up with the address of non-allocated memory (a dangling pointer), which will cause problems if used. This is a common mistakes that new programmers make. Many newer compilers will give a warning (not an error) if the programmer tries to return a local variable by address -- however, there are quite a few ways to trick the compiler into letting you do something illegal without generating a warning, so the burden is on the programmer to ensure the address they are returning will be to a valid variable after the function returns.
Return by address is often used to return dynamically allocated memory to the caller:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
int* allocateArray(int size)
{
    return new int[size];
}
 
int main()
{
    int *array = allocateArray(25);
 
    // do stuff with array
 
    delete[] array;
    return 0;
}

When to use return by address:
When returning dynamically allocated memory
When returning function arguments that were passed by address
When not to use return by address:
When returning variables that were declared inside the function (use return by value)
When returning a large struct or class (use return by reference)
Return by reference
Similar to pass by address, values returned by reference must be variables (you can not return a reference to a literal or an expression). When a variable is returned by reference, a reference to the variable is passed back to the caller. The caller can then use this reference to continue modifying the variable, which can be useful at times. Return by reference is also fast, which can be useful when returning structs and classes.
However, just like return by address, you should not return local variables by reference. Consider the following example:
1
2
3
4
5
int& doubleValue(int x)
{
    int value = x * 2;
    return value; // return a reference to value here
} // value is destroyed here

In the above program, the program is returning a reference to a value that will be destroyed when the function returns. This would mean the caller receives a reference to garbage. Fortunately, your compiler will probably give you a warning or error if you try to do this.
Return by reference is typically used to return arguments passed by reference to the function back to the caller. In the following example, we return (by reference) an element of an array that was passed to our function by reference:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
#include <array>
#include <iostream>
 
// Returns a reference to the index element of array
int& getElement(std::array<int, 25> &array, int index)
{
    // we know that array[index] will not be destroyed when the function ends
    // so it's okay to return it by reference
    return array[index];
}
 
int main()
{
    std::array<int, 25> array;
 
    // Set the element of array with index 10 to the value 5
    getElement(array, 10) = 5;
	
    std::cout << array[10] << '\n';
 
    return 0;
}

This prints:
5
When we call getElement(array, 10), getElement() returns a reference to the array element with index 10. main() then uses this reference to assign that element the value 5.
Although this is somewhat of a contrived example (because you can access array[10] directly), once you learn about classes you will find a lot more uses for returning values by reference.
When to use return by reference:
When returning a reference parameter
When returning a large struct or class that has scope outside of the function
When not to use return by reference:
When returning variables that were declared inside the function (use return by value)
When returning a built-in array or pointer value (use return by address)
Mixing return references and values
Although a function may return a value or a reference, the caller may or may not assign the result to a value or reference accordingly. Let’s look at what happens when we mix value and reference types.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
int returnByValue()
{
    return 5;
}
 
int& returnByReference()
{
     static int x = 5; // static ensures x isn't destroyed when it goes out of scope
     return x;
}
 
int main()
{
    int value = returnByReference(); // case A -- ok, treated as return by value
    int &ref = returnByValue(); // case B -- compile error
    const int &cref = returnByValue(); // case C -- ok, the lifetime of return value is extended to the lifetime of cref
}

In case A, we’re assigning a reference return value to a non-reference variable. Because value isn’t a reference, the return value is copied into value, as if returnByReference() had returned by value. In case B, we’re trying to initialize reference ref with the copy of the return value returned by returnByValue(). However, because the value being returned doesn’t have an address (it’s an rvalue), this will cause a compile error.
In case C, we’re trying to initialize const reference ref with the copy of the return value returned by returnByValue(). Because const references can be assigned to rvalues, perhaps surprisingly, this actually works! The lifetime of the return value is extended to match the lifetime of cref so that it doesn’t die until cref does.
Conclusion
Most of the time, return by value will be sufficient for your needs. It’s also the most flexible and safest way to return information to the caller. However, return by reference or address can also be useful, particularly when working with dynamically allocated classes or structs. When using return by reference or address, make sure you are not returning a reference to, or the address of, a variable that will go out of scope when the function returns!
 
 
 
 
 
 
 
 
 

Classes and class members
Here is an example of a struct used to hold a date:
1
2
3
4
5
6
struct DateStruct
{
    int year;
    int month;
    int day;
};

Classes:  A class in C++ is a user defined type or data structure declared with keyword class that has data and functions (also called methods) as its members whose access is governed by the three access specifiers private, protected or public (by default access to members of a class is private)
In the world of object-oriented programming, we often want our types to not only hold data, but provide functions that work with the data as well. In C++, this is typically done via the class keyword. Using the class keyword defines a new user-defined type called a class.
In C++, classes are very much like data-only structs, except that classes provide much more power and flexibility. In fact, the following struct and class are effectively identical:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
struct DateStruct
{
    int year;
    int month;
    int day;
};
 
class DateClass
{
public:
    int m_year;
    int m_month;
    int m_day;
};

Member Functions
In addition to holding data, classes can also contain functions! Functions defined inside of a class are called member functions (or sometimes methods). Here is our Date class with a member function to print the date:
Rule: Name your classes starting with a capital letter.

Public vs private access specifiers

Public members are members of a struct or class that can be accessed from outside of the struct or class.

Private members are members of a class that can only be accessed by other members of the class

Access functions and encapsulation
In object-oriented programming, Encapsulation (also called information hiding) is the process of keeping the details about how an object is implemented hidden away from users of the object. Instead, users of the object access the object through a public interface. In this way, users are able to use the object without having to understand how it is implemented.

In C++, we implement encapsulation via access specifiers. Typically, all member variables of the class are made private (hiding the implementation details), and most member functions are made public (exposing an interface for the user).

Benefit: encapsulated classes are easier to use and reduce the complexity of your programs.
With a fully encapsulated class, you only need to know what member functions are publicly available to use the class, what arguments they take, and what values they return. It doesn’t matter how the class was implemented internally.  

Global variables are dangerous because you don’t have strict control over who has access to the global variable, or how they use it. Classes with public members suffer from the same problem, just on a smaller scale.
For example, let’s say we were writing a string class. We might start out like this:
1
2
3
4
5
class MyString
{
    char *m_string; // we'll dynamically allocate our string here
    int m_length; // we need to keep track of the string length
};

These two variables have an intrinsic connection: m_length should always equal the length of the string held by m_string. If m_length were public, anybody could change the length of the string without changing m_string (or vice-versa). This would put the class into an inconsistent state, which could cause all sorts of bizarre problems. By making both m_length and m_string private, users are forced to use whatever public member functions are available to work with the class (and those member functions can ensure that m_length and m_string are always set appropriately). 
 
e can also help protect the user from mistakes in using our class. Consider a class with an public array member variable:
1
2
3
4
5
class IntArray
{
public:
    int m_array[10];
};

If users can access the array directly, they could subscript the array with an invalid index, producing unexpected results:
1
2
3
4
5
int main()
{
    IntArray array;
    array.m_array[16] = 2; // invalid array index, now we overwrote memory that we don't own
}

However, if we make the array private, we can force the user to use a function that validates that the index is valid first:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
class IntArray
{
private:
    int m_array[10]; // user can not access this directly any more
 
public:
    void setValue(int index, int value)
    {
        // If the index is invalid, do nothing
        if (index < 0 || index >= 10)
            return;
 
        m_array[index] = value;
    }
};

In this way, we’ve protected the integrity of our program. As a side note, the at() function of std::array and std::vector do something very similar!
Benefit: encapsulated classes are easier to change
 
Rule: Only provide access functions when it makes sense for the user to be able to get or set a value directly.
Rule: Getters should usually return by value or const reference, not non-const reference














Inheritance:

Instantiating Base
Base
Instantiating Derived
Base
Derived
As you can see, when we constructed Derived, the Base portion of Derived got constructed first. This makes sense: logically, a child can not exist without a parent. It’s also the safe way to do things: the child class often uses variables and functions from the parent, but the parent class knows nothing about the child. Instantiating the parent class first ensures those variables are already initialized by the time the derived class is created and ready to use them.
 
 
Conclusion
C++ constructs derived classes in phases, starting with the most-base class (at the top of the inheritance tree) and finishing with the most-child class (at the bottom of the inheritance tree). As each class is constructed, the appropriate constructor is called.
Multiple inheritance:
#include<iostream>
#include<conio.h>


using namespace std;

class A
{
public:
	A()
	{
		cout<<"A constructor called"<<endl;
	}
};

class B
{
public:
	B()
	{
		cout<<"B constructor"<<endl;
	}
};


class C:public A,public B
{
public:
	C()
	{
		cout<<"c constructor"<<endl;
	}
};


int main()
{

	C obj;

	return 0;
}
Output:
A then b then c constructor
 
Passing parameters to base class:
#include<iostream>
#include<conio.h>


using namespace std;

class A
{

private:
	int a;
public:
	A(int p=0)
	{
		a=p;
	}
	int geta()
	{
		return a;
	}
};

class B:public A
{
private:
	int b;
public:

	int getb()
	{
		return b;
	}
	B(int q=0,int r=0):A(q)
	{
		b=r;
	}
};


int main()
{

	B obj(20,100);
	cout<<obj.geta()<<endl;
	cout<<obj.getb()<<endl;

	return 0;
}

Output:20,100

The declaration of the derived class constructor should have arguments that are passed to the base class as well as arguments that are passed to the derived class followed by colon and exclusively calling the base class constructor with parameters to it.
 Passing parameters in multiple inheritance
 
#include<iostream>
#include<conio.h>

using namespace std;


class A
{
private:
	int a;
public:
	A(int p=0)
	{
		a=p;
	}

	int geta()
	{
		return a;
	}
};

class B
{
private:
	int b;
public:
	B(int p=0)
	{
		b=p;
	}

	int getb()
	{
		return b;
	}
};

class C:public A,public B
{
private:
	int c;

public:
	C(int i=0,int j=0,int k=0):A(i),B(j)
	{
		c=k;
	}

	int getc()
	{
		return c;
	}
};


int main()
{
	C ob(10,20,100);

	cout<<"a is"<<ob.geta()<<endl;
	cout<<"b is"<<ob.getb()<<endl;
	cout<<"c is"<<ob.getc()<<endl;

	return 0;
}


Function overriding:
When we have same function name and signature in base and derived class.Depending on object on which its called it calls as shown below.

#include<iostream>
#include<conio.h>

using namespace std;

class Person
{
public:
	void Introduce()
	{
		cout<<"Hi"<<endl;
	}
};

class Student:public Person
{
public:
	void Introduce()
	{
		cout<<"Hi and hello"<<endl;
	}
};


int main()
{
	Person obj;
	obj.Introduce();  //calls Hi

Student ob;
Ob.Introduce();// calls hi and hello
	return 0;
}

Accessing overridden methods in the base class:

In the above example if you want to use introduce of base class in derived class code as below.

int main()
{
	Person obj;
	obj.Person::Introduce();

	return 0;
}

Now it will call base class ka introduce.

Following code shows how to call base class method in derived class

#include<iostream>
#include<conio.h>

using namespace std;

class Person
{
public:
	void Introduce()
	{
		cout<<"Hi"<<endl;
	}
};

class Student:public Person
{
public:
	void Introduce()
	{
		Person::Introduce();
		cout<<"Hi and hello"<<endl;
	}
};



int main()
{
	Student obj;
	obj.Introduce();

	return 0;
}


GRANTING ACCESS 
When a base class is inherited as private,all public and protected members of the base class become private members of the derived class.If we want some of the members to retain their public or protected status in derived class also as in base class then we can grant access only to those members.

Syntax:

Base-class::member

#include<iostream>
#include<conio.h>

using namespace std;

class X
{
public:
	int i,j;
protected:
	int p,q;
};

class Y:public X
{
public:
	X::i;

protected:
	X::p;

};


int main()
{
Y obj;

obj.i;   //as its public in derived  by using grat access
}


TYPES OF INHERITANCE:    refer vtu book

1.single inheritance

base
 
derived


2.Multiple inheritance 

Polymorphism
Polymorphism means having multiple forms of one thing. In inheritance, polymorphism is done, by method overriding, when both super and sub class have member function with same declaration bu different definition.

Function Overriding
If we inherit a class into the derived class and provide a definition for one of the base class's function again inside the derived class, then that function is said to be overridden, and this mechanism is called Function Overriding

Requirements for Overriding
Inheritance should be there. Function overriding cannot be done within a class. For this we require a derived class and a base class.
Function that is redefined must have exactly the same declaration in both base and derived class, that means same name, same return type and same parameter list.

Example of Function Overriding
class Base
{
 public:
 void show()
 {
  cout << "Base class";
 }
};
class Derived:public Base
{
 public:
 void show()
 {
  cout << "Derived Class";
 }
}
In this example, function show() is overridden in the derived class. Now let us study how these overridden functions are called in main() function.

Function Call Binding with class Objects
Connecting the function call to the function body is called Binding. When it is done before the program is run, its called Early Binding or Static Binding or Compile-time Binding.
class Base
{
 public:
 void shaow()
 {
  cout << "Base class\t";
 }
};
class Derived:public Base
{
 public:
 void show()
 {
  cout << "Derived Class";
 }
}
 
int main()
{
 Base b;       //Base class object
 Derived d;     //Derived class object
 b.show();     //Early Binding Ocuurs
 d.show();   
}
Output : Base class    Derived class
In the above example, we are calling the overrided function using Base class and Derived class object. Base class object will call base version of the function and derived class's object will call the derived version of the function.

Function Call Binding using Base class Pointer
But when we use a Base class's pointer or reference to hold Derived class's object, then Function call Binding gives some unexpected results.
class Base
{
 public:
 void show()
 {
  cout << "Base class";
 }
};
class Derived:public Base
{
 public:
 void show()
 {
  cout << "Derived Class";
 }
}
 
int main()
{
 Base* b;       //Base class pointer
 Derived d;     //Derived class object
 b = &d;
 b->show();     //Early Binding Occurs
}
Output : Base class
In the above example, although, the object is of Derived class, still Base class's method is called. This happens due to Early Binding.
Compiler on seeing Base class's pointer, set call to Base class's show() function, without knowing the actual object type.






Virtual functions and polymorphism

The members of base class can be accessed by using two methods
1.Using base class pointer:

#include<iostream>
#include<conio.h>


using namespace std;

class X
{
public:
	void show()
	{
		cout<<"base class"<<endl;
	}
};


class Y:public X
{
public:
	void show()
	{
		cout<<"derived class Y"<<endl;
	}
};


class Z:public Y
{
public:
	void show()
	{
		cout<<"drived class Z"<<endl;
	}
};


int main()
{
	X *pbase;

	X ob1;

	pbase=&ob1;
	pbase->show();

	Y obY;
	pbase=&obY;
	pbase->show();


	return 0;
}

Output:
Base class
Base class

int main()
{
	Y *pbase;

	Y ob1;

	pbase=&ob1;
	pbase->show();

	Y obY;
	pbase=&obY;
	pbase->show();


	return 0;
}


Output:
Derived class y
Derived class y

Conclusion: In this approach compiler will decide which function to be invoked considering the type of the pointer, but not by the address of the object stored in the pointer.

2. Using reference to a base class:
int main()
{
//using reference to a base class

	X ob1;
	X &a=ob1;
	a.show();

	Y obY;
	X &b=obY;
	b.show();


	return 0;
}

Output:
Base class,base class

int main()
{
//using reference to a base class

	Y ob1;
	Y &a=ob1;
	a.show();

	Y obY;
	Y &b=obY;
	b.show();


	return 0;
}

Output:
Derived class y ,derived class y

Note:in this approach compiler will decide which function has to be invoked by considering the reference type,not by the object equated to the reference variable.

This is early bindng.->compiler decides based on pointer type.
Some points to be remembered from above example:
1.Using base class pointers only member functions of base class are invoked.
2.Even if address of member functions of derived class are stored in base class pointer,it will not have any effect and only member functions of base class are invoked.
3.In this type of approach,compiler will decide which function has to be called by considering type of the base class pointer .But not by the address of th object stored in the pointer.
4.The type of the object in the pointer is never considered by the compiler and it is ignored by the compiler.this is because the function call is bound to the actual function during compile time.So,it is known as compile time binding or early binding or static binding.

Early binding:
Early Binding: Events occurring at compile time are known as early binding. In the process of early binding all info which is required for a function call is known at compile time. Early binding is a fast and efficient process. Examples of early binding: function calls, overloaded function calls, and overloaded operators.
In this type of approach,compiler will decide which function has to be called by considering type of the base class pointer .But not by the address of th object stored in the pointer.

Late binding:
Late Binding: In this process all info which is required for a function call is not known at compile time. Hence, objects and functions are not linked at run time. Late Binding is a slow process. However, it provides flexibility to the code. Example of Late Binding: Virtual functions.
































VIRTUAL FUNCTIONS:
Virtual Function is a function in base class, which is overrided in the derived class, and which tells the compiler to perform Late Binding on this function.
Virtual Keyword is used to make a member function of the base class Virtual.
When a class containing virtual function is inherited,the virtual function is redefined in the derived class.
The virtual function of the base class is called overridden function and the virtual function which is redefined in the derived class is called overriding function.

The virtual member function in the derived class can have an optional prefix virtual.

Late Binding
In Late Binding function call is resolved at runtime. Hence, now compiler determines the type of object at runtime, and then binds the function call. Late Binding is also called Dynamic Binding or Runtime Binding. 
 
On using Virtual keyword with Base class's function, Late Binding takes place and the derived version of function will be called, because base class pointer pointes to Derived class object.
 
Following example shows exmpale of late binding
#include<iostream>
#include<conio.h>

using namespace std;

class X
{
public:
	virtual void  show()
	{
		cout<<"base class X"<<endl;
	}
};

class Y:public X
{
public:
	void show()
	{
		cout<<"class Y"<<endl;
	}
};

class Z:public X
{
public:
	void display()
	{

	}
};


int main()
{
X *pbase;
X obX;

pbase=&obX;
pbase->show(); //calls base class X

Y obY;
pbase=&obY;
pbase->show(); //cals class Y

Z obZ;
pbase=&obZ;
pbase->show(); //as Z doest have virtual function cals show() of its base class which is X class

return 0;
}
 
If overriding function does not occur in derived class,the overiiden function in the parent is called.
Observe in the above example tht the decision of which overriding function of derived class is executed is made at run time and hence its termend as RUN TIME POLYMORPHISM.
Virtual functions behave like normal functions when they are accesd in the usual manner.as shown in following exmpale
They behave differently when accesed using base class pointer and when accesed using reference variable.

#include<iostream>
#include<conio.h>

using namespace std;

class X
{
public:
	virtual void  show()
	{
		cout<<"base class X"<<endl;
	}
};

class Y:public X
{
public:
	void show()
	{
		cout<<"class Y"<<endl;
	}
};


int main()
{
X ob1;
ob1.show();//cals show of X

Y ob2;
ob2.show();  //cals show of Y

return 0;
}

Using Virtual Keyword and Accessing Private Method of Derived class
We can call private function of derived class from the base class pointer with the help of virtual keyword. Compiler checks for access specifier only at compile time. So at run time when late binding occurs it does not check whether we are calling the private function or public function.

Following example shows this 
#include<iostream>
#include<conio.h>

using namespace std;

class X
{
public:
	virtual void  show()
	{
		cout<<"base class X"<<endl;
	}
};

class Y:public X
{
private:
	void show()
	{
		cout<<"class Y"<<endl;
	}
};


int main()
{
X *pbase;
X obX;

Y obY;
pbase=&obY;
pbase->show();  //calls class Y

return 0;
}
MECHANISM OF VIRTUAL FUNCTIONS 

This concept can be explained by following example 
#include<iostream>
#include<conio.h>

using namespace std;

class X
{
public:
	virtual void  show()
	{
		cout<<"base class X"<<endl;
	}
	virtual void display()
	{
		cout<<"base display"<<endl;
	}
Void nothing()
{
}
};

class Y:public X
{
private:
	void show()
	{
		cout<<"class Y"<<endl;
	}
};


int main()
{
X *pbase;
X obX;

pbase=&obX;

pbase->show();
pbase->display();

Y obY;
pbase=&obY;
pbase->show();  //calls class Y
pbase->display();

return 0;
}






Explanation:

1. creation of table of addresses for base class
If base class has a virtual function,then a table called VTABLE is created during the run time.
Address of all virtual functions are entered in to that table.
The non virtual functions will not be entered in the vtable.

In the above example 

Vtable for base class X

                                                   Addrees of function show of base class


                                                     Address of function display of base class 





Object of X




Object of X will have pointer called vptr which points to vtable of base clas as show above.

Vtable for derived class
                                                    As derived class has show() its adrees is replaced with adres of                 
                                                    show in derived class(3000).

                                                   As derived class don’t have display base class address of display 
                                                     Is entered in to vtable of derived class.                                                         


Object of derived class Y






Object of Y will have pointer called vptr which points to vtable of derived clas as show above.

Note:Size of an object with virtual functions will be 4 bytes larger than the size of object without virtual functions.This extra 4 bytes represent a pointer to vtable which is vptr
int main()
{
X *pbase;
X obX;

pbase=&obX;//object in base class pointer is of type X.So vptr of base class

pbase->show(); //pbase has object of x.use vptr of base class check for show ka adrees                           and call tht 
pbase->display();  //same as above

Y obY;
pbase=&obY;
pbase->show();  //calls class Y
pbase->display();   //calls display of base as derived don’t has

return 0;
}

Important Points to Remember
Only the Base class Method's declaration needs the Virtual Keyword, not the definition.
If a function is declared as virtual in the base class, it will be virtual in all its derived classes.
The address of the virtual Function is placed in the VTABLE and the copiler uses VPTR(vpointer) to point to the Virtual Function.
PURE VIRTUAL FUNCTIONS:A pue virtual function is a virtual function declared inside the base class and has no definition relative to base calss.
A virtual function equated to zero is called pure virtual function.
Ex:virtual type fun-name(para)=0
If the derived class doest  override the pure virtual function,then compiler will display error.
We know that
1.a virtual function may or may not be overrideen in the derived class.But in some situations we want to ensure that all derived alasses must override a virtual function.
2.In most of cases,the base class may not have any meaningfull definition of virtual function.In such case every derived class must provide its own definition of tht function by redifinfing it.
The above two situations can be handled using pure virtual functions.
 
Virtual functions
Pure virtual functions
Virtual functions can be defined inside the base class.
Pure virtual functions cannot be defined inside the base class.
The virtual functions in the derived class may or may not be overridden.
The virtual functions in the derived class must be overridden.
A class containing the virtual functions can be used to declare any object of the class.
A class containing pure virtual functions cannot be used to declare any object of class.

ABSTARCT CLASS:
Abstract Class is a class which contains atleast one Pure Virtual function in it. Abstract classes are used to provide an Interface for its sub classes. Classes inheriting an Abstract Class must provide definition to the pure virtual function, otherwise they will also become abstract class.
Characteristics of Abstract Class
Abstract class cannot be instantiated, but pointers and refrences of Abstract class type can be created.
Abstract class can have normal functions and variables along with a pure virtual function.
Abstract classes are mainly used for Upcasting, so that its derived classes can use its interface.
Classes inheriting an Abstract Class must implement all pure virtual functions, or else they will become Abstract too.
Example of Abstract Class
class Base          //Abstract base class
{
 public:
 virtual void show() = 0;            //Pure Virtual Function
};
 
class Derived:public Base
{
 public:
 void show()
 { cout << "Implementation of Virtual Function in Derived class"; }
};
 
int main()
{
 Base obj;       //Compile Time Error
 Base *b;
 Derived d;
 b = &d;
 b->show();
}
Output :
Implementation of Virtual Function in Derived class
In the above example Base class is abstract, with pure virtual show() function, hence we cannot create object of base class.
 
Why can't we create Object of Abstract Class ?
When we create a pure virtual function in Abstract class, we reserve a slot for a function in the VTABLE(studied in last topic), but doesn't put any address in that slot. Hence the VTABLE will be incomplete.
As the VTABLE for Abstract class is incomplete, hence the compiler will not let the creation of object for such class and will display an errror message whenever you try to do so.
 
 
 

Virtual Destructors
Destructors in the Base class can be Virtual. Whenever Upcasting is done, Destructors of the Base class must be made virtual for proper destrucstion of the object when the program exits.
NOTE : Constructors are never Virtual, only Destructors can be Virtual.

Upcasting without Virtual Destructor
Lets first see what happens when we do not have a virtual Base class destructor.
class Base
{
 public:
 ~Base() {cout << "Base Destructor\t"; }
};
 
class Derived:public Base
{
 public:
 ~Derived() { cout<< "Derived Destructor"; }
}; 
 
int main()
{
 Base* b = new Derived;     //Upcasting
 delete b;
}
Output :
Base Destructor
In the above example, delete b will only call the Base class destructor, which is undesirable because, then the object of Derived class remains undestructed, because its destructor is never called. Which results in memory leak.

Upcasting with Virtual Destructor
Now lets see. what happens when we have Virtual destructor in the base class.
class Base
{
 public:
 virtual ~Base() {cout << "Base Destructor\t"; }
};
 
class Derived:public Base
{
 public:
 ~Derived() { cout<< "Derived Destructor"; }
}; 
 
int main()
{
 Base* b = new Derived;     //Upcasting
 delete b;
}
Output :
Derived Destructor
Base Destructor
When we have Virtual destructor inside the base class, then first Derived class's destructor is called and then Base class's destructor is called, which is the desired behaviour.
 
Pure Virtual Destructors
Pure Virtual Destructors are legal in C++. Also, pure virtual Destructors must be defined, which is against the pure virtual behaviour.
The only difference between Virtual and Pure Virtual Destructor is, that pure virtual destructor will make its Base class Abstract, hence you cannot create object of that class.
There is no requirement of implementing pure virtual destructors in the derived classes.
class Base
{
 public:
 virtual ~Base() = 0;     //Pure Virtual Destructor
};
 
Base::~Base() { cout << "Base Destructor"; } //Definition of Pure Virtual Destructor
 
class Derived:public Base
{
 public:
 ~Derived() { cout<< "Derived Destructor"; }
}; 
 
 
Early Binding 
Late Binding
Binding an object to a function call is done during compilation time.
Binding an object to a function call is done during run time.
Refers to events that occur during compile time.
Refers to the events that occur during run time
Since function call is resolved during compile time,execution is faster.
Execution is slower.
Not flexible as functions to be executed are decided during the compilation time
Flexible as the functions to be executed are decided during run time
Achieved using normal fun calls,func overloading,opeartro overloading
Achieved using inheritance and virtual functions
Its called static binding
Its called dynamic binding 

 
Overloading 
Overriding 
Member functions have same name and deferent signatures.Type of parameters are different ,return type may same or may not be same
Member functions have same name and same signatures.Return type must be same
Supports compile time polymorphism
Supports run time polymorphism
Overloaded functions can be friends
Overriding functions cannot be friends. 
Constructors can be overloaded 
Constructors cannot be overridden as they cannot be virtual
Destructors cannot be overloaded
Destructors can be overloaded as they can be virtual

 
 
 
 
SMART POINTERS :
Smart pointers are class objects that behave like built-in pointers but also manage objects that you create with new so that you don't have to worry about when and whether to delete them - the smart pointers automatically delete the managed object for you at the appropriate time. 
A smart pointer contains a built-in pointer, and is defined as a template class whose type parameter is the type of the pointed-to object, so you can declare smart pointers that point to a class object of any type.
Smart pointers make it easier to implement ownership correctly by making the smart pointer destructor the place where the object is deleted. Since the compiler ensures that the destructor of a class object will be called when the object is destroyed, the smart pointer destruction can then automatically handle the deletion of the pointed-to object. The smart pointer owns the object and handles the deletion for us.
 
 
References in C++
References are like constant pointers that are automatically dereferenced. It is a new name given to an existing storage. So when you are accessing the reference, you are actually accessing that storage.
int main()
{ int y=10;
  int &r = y;  // r is a reference to int y
  cout << r;
}
Output :
10
There is no need to use the * to dereference a reference variable.
Difference between Reference and Pointer
References
Pointers
Reference must be initialized when it is created.
Pointers can be initialized any time.
Once initialized, we cannot reinitialize a reference.
Pointers can be reinitialized any number of time.
You can never have a NULL reference.
Pointers can be NULL.
Reference is automatically dereferenced.
* is used to dereference a pointer.

 
References in Funtions
References are generally used for function argument lists and function return values, just like pointers.
Rules for using Reference in Functions
When we use reference in argument list, we must keep in mind that any change to the reference inside the function will cause change to the original argument outside th function.
When we return a reference from a function, you should see that whatever the reference is connected to shouldn't go out of scope when fnction ends. Either make that global or static
Example to explain use of References



int* first (int* x)
{ (*x++);
  return x;   // SAFE, x is outside this scope
}
 
int& second (int& x)
{ x++;
  return x;   // SAFE, x is outside this scope
}
 
int& third ()
{ int q;
  return q;   // ERROR, scope of q ends here
}
 
int& fourth ()
{ static int x;
  return x;   // SAFE, x is static, hence lives till the end.
}
 
int main()
{
 int a=0;
 first(&a);   // UGLY and explicit
 second(a);   // CLEAN and hidden
}
We have four different functions in the above program.
first() takes a pointer as argument and returns a pointer, it will work fine. The returning pointer points to variable declared outside first(), hence it will be valid even after the first() ends.
Similarly, second() will also work fine. The returning reference is connected to valid storage, that is int ain this case.
But in case of third(), we declare a variable q inside the function and try to return a reference connected to it. But as soon as function third() ends, the local variable q is destroyed, hence nothing is returned.
To remedify above problem, we make x as static in function fourth(), giving it a lifetime till main() ends, hence now a reference connected to x will be valid when returned.
Const Reference
Const reference is used in function arguments to prevent the function from changing the argument.
void g(const int& x)
{ x++; }   // ERROR
 
int main()
{
 int i=10;
 g(i);
}
We cannot change the argument in the function because it is passed as const reference.
 
 
Argument Passing Guidelines
Usually call by value is used during funtcion call just to save our object or variable from being changed or modified, but whenever we pass an argument by value, its new copy is created. If we pass an object as argument then a copy of that object is created (constructor and destructors called), which affects efficiency.
Hence, we must use const reference type arguments. When we use, const reference, only an address is passed on stack, which is used inside the function and the function cannot change our argument because it is of const type.
So using const reference type argument reduces overhead and also saves our argument from being changed.
 
 
Static Member functions
Static is something that holds its position. Static is a keyword which can be used with data members as well as the member functions. We will discuss this in details later. As of now we will discuss its usage with member functions only.
A function is made static by using static keyword with function name. These functions work for the class as whole rather than for a particular object of a class.
It can be called using the object and the direct member access . operator. But, its more typical to call a static member function by itself, using class name and scope resolution :: operator.
Example :
class X
{
 public:
 static void f(){};
};
 
int main()
{
 X::f();   // calling member function directly with class name
}
These functions cannot access ordinary data members and member functions, but only static data members and static member functions.
It doesn't have any "this" keyword which is the reason it cannot access ordinary members. We will study about "this" keyword later.
 
Const Member functions
We will study Const keyword in detail later, but as an introduction, Const keyword makes variables constant, that means once defined, there values can't be changed.
When used with member function, such member functions can never modify the object or its related data members.
//Basic Syntax of const Member Function
 
void fun() const {}
 
 
Rules for using Default Arguments
Only the last argument must be given default value. You cannot have a default argument followed by non-default argument.
sum (int x,int y);    
sum (int x,int y=0);  
sum (int x=0,int y);  // This is Incorrect
If you default an argument, then you will have to default all the subsequent arguments after that.
sum (int x,int y=0);
sum (int x,int y=0,int z);  // This is incorrect
sum (int x,int y=10,int z=10);  // Correct
You can give any value a default value to argument, compatible with its datatype.
Placeholder Arguments
When arguments in a function are declared without any identifier they are called placeholder arguments.
void sum (int,int);
Such arguments can also be used with default arguments.
void sum (int, int=0);
 
A default constructor is so important for initialization of object members, that even if we do not define a constructor explicitly, the compiler will provide a default constructor implicitly.
class Cube
{
 int side;
};
 
int main()
{
 Cube c;
 cout << c.side;
}
Output : 0
In this case, default constructor provided by the compiler will be called which will initialize the object data members to default value, that will be 0 in this case.
A default constructor is so important for initialization of object members, that even if we do not define a constructor explicitly, the compiler will provide a default constructor implicitly.
class Cube
{
 int side;
};
 
int main()
{
 Cube c;
 cout << c.side;
}
Output : 0
In this case, default constructor provided by the compiler will be called which will initialize the object data members to default value, that will be 0 in this case.
 One more important thing, if you define any constructor explicitly, then the compiler will not provide default constructor and you will have to define it yourself.
 
Single Definition for both Default and Parameterized Constructor
In this example we will use default argument to have a single definition for both defualt and parameterized constructor.
class Dual
{
 int a;
 public:
 Dual(int x=0)
  {
   a=x;
  }
};
 
int main()
{
 Dual obj1;
 Dual obj2(10);
}
Here, in this program, a single Constructor definition will take care for both these object initializations. We don't need separate default and parameterized constructors.
 
Namespace
Namespace is a container for identifiers. It puts the names of its members in a distinct space so that they don't conflict with the names in other namespaces or global namespace.
Rules to create Namespace
The namespace definition must be done at global scope, or nested inside another namespace.
Namespace definition doesn't terminates with a semicolon like in class definition.
You can use an alias name for your namespace name, for ease of use. Example for Alias :
namespace StudyTonightDotCom
{
 void study();
 class Learn {  };
}
 
namespace St = StudyTonightDotCom;     // St is now alias for StudyTonightDotCom
You cannot create instance of namespace.
There can be unnamed namespaces too. Unnamed namespace is unique for each translation unit. They act exactly like named namespaces. Example for Unnamed namespace :
namespace
{
 class Head { };
 class Tail { };
 int i,j,k;
}
 
int main() { }
A namespace definition can be continued and extended over multiple files, they are not redefined or overriden. Example :
 Header1.h
 
namespace MySpace
{
 int x;
 void f();
}
 
 Header2.h
 
#include "Header1.h";
namespace MySpace
{
 int y;
 void g();
}
Static class Objects
Static keyword works in the same way for class objects too. Objects declared static are allocated storage in static storage area, and have scope till the end of program.
Static objects are also initialized using constructors like other normal objects. Assignment to zero, on using static keyword is only for primitive datatypes, not for user defined datatypes.
class Abc
{
 int i;
 public:
 Abc()
 {
  i=0;
  cout << "constructor";
 }
 ~Abc()
 {
   cout << "destructor";
 }
};
 
void f()
{
 static Abc obj;
}
 
int main()
{
 int x=0;
 if(x==0)
 {
  f();
 }
 cout << "END";
}
Output :
constructor END destructor
You must be thinking, why was destructor not called upon the end of the scope of if condition. This is because object was static, which has scope till the program lifetime, hence destructor for this object was called when main() exits.
 
Static data member in class
Static data members of class are those members which are shared by all the objects. Static data member has a single piece of storage, and is not available as separate copy with each object, like other non-static data members.
Static member variables (data members) are not initialied using constructor, because these are not dependent on object initialization.
Also, it must be initialized explicitly, always outside the class. If not initialized, Linker will give error.
class X
{
 static int i;
 public:
 X(){};
};
 
int X::i=1;
 
int main()
{
 X obj;
 cout << obj.i;   // prints value of i
}
 
Once the definition for static data member is made, user cannot redefine it. Though, arithmetic operations can be performed on it.
 
Static Member Functions:
These functions work for the class as whole rather than for a particular object of a class.
It can be called using an object and the direct member access . operator. But, its more typical to call a static member function by itself, using class name and scope resolution :: operator.
Example :
class X
{
 public:
 static void f(){};
};
 
int main()
{
 X::f();   // calling member function directly with class name
}
These functions cannot access ordinary data members and member functions, but only static data members and static member functions.
It doesn't have any "this" keyword which is the reason it cannot access ordinary members. We will study about "this" keyword later.
 
2) Pointers with Const
Pointers can be made const too. When we use const with pointers, we can do it in two ways, either we can apply const to what the pointer is pointing to, or we can make the pointer itself a const.





Pointer to Const
This means that the pointer is pointing to a const variable.
const int* u;
Here, u is a pointer that points to a const int. We can also write it like,
int const* v;
still it has the same meaning. In this case also, v is a pointer to an int which is const.


Const pointer
To make the pointer const, we have to put the const keyword to the right of the *.
int x = 1;
int* const w = &x;
Here, w is a pointer, which is const, that points to an int. Now we can't change the pointer but can change the value that it points to.
NOTE : We can also have a const pointer pointing to a const variable.
const int* const x;
 
 
Some Important points to remember
For built in types, returning a const or non-const, doesn't make any difference.
const int h()
{
 return 1;
}
it main()
{
 const int j = h();
 int k = h();
}
Both j and k will be assigned 1. No error will occur.
For user defined data types, returning const, will prevent its modification.
Temporary objects created while program execution are always of const type.
If a function has a non-const parameter, it cannot be passed a const argument while making a call.
void t(int*) { }
If we pass a const int* argument, it will give error.
But, a function which has a const type parameter, can be passed a const type argument as well as a non-const argument.
void g(const int*) {}
This function can have a int* as well as const int* type argument.
 
Pointers to data members
Some Points to remember
You can change the value and behaviour of these pointers on runtime. That means, you can point it to other member function or member variable.
To have pointer to data member and member functions you need to make them public.
 
Lvalue and rvalue
What is an lvalue and rvalue?
An lvalue refers to an object that persists beyond a single expression. You can think of an lvalue as an object that has a name. All variables, including nonmodifiable ( const ) variables, are lvalues. An rvalue is a temporary value that does not persist beyond the expression that uses it.
Lvalue===========positions/memory locations
Rvalue===========value at location
 
Reference to pointer vvvvvvvvvvvvvvvvvvvvimp
//global variable
int g_One=1;
//function prototype
void func(int* pInt);
 
int main()
{
  int nvar=2;
  int* pvar=&nvar;
  func(pvar);
  std::cout<<*pvar<<std::endl;    //Will still show 2
  return 0;
}
 
void func(int* pInt)
{
  pInt=&g_One;
How to change the pointer using refrence to pointer
#include<iostream>
#include<conio.h>

using namespace std;

//global varibale

int global_var=20;

void ModifyPtr(int *&ptr)
{
	ptr=&global_var;
}

int main()
{
	int m=45;

	int *Optr= &m;

	ModifyPtr(Optr);

	cout<<*Optr<<endl;
}
Pointer to Pointer
Syntax of Pointer-to-Pointer
This is how you call the function with a ptr-to-ptr parameter:
//function prototype
void func(int** ppInt);
 
int main()
{
  int nvar=2;
  int* pvar=&nvar;
  func(&pvar);
  ....
  return 0;
}
Let us see how to modify the pointer in the function using a ptr-to-ptr parameter
void func(int** ppInt)
{
  //Modify the pointer ppInt points to
  *ppInt=&g_One;
  //You can also allocate memory, depending on your requirements
  *ppInt=new int;
  //Modify the variable *ppInt points to
  **ppInt=3;
}
 
 
