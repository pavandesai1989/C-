0. unique_ptr is a class template.
1. unique_ptr is one of the smart pointer provided by c++11 to prevent memory leaks.
2. unique_ptr wraps a raw pointer in it, and de-allocates the raw pointer,
   when unique_ptr object goes out of scope.
3. similar to actual pointers we can use arrow and * on the object of unique_ptr,  because it is overloaded in unique_ptr class.
4. When exception comes then also it will de-allocate the memory hence no memory leak.
5. Not only object we can create array of objects of unique_ptr.

*******msdn link for good points******
https://docs.microsoft.com/en-us/cpp/cpp/how-to-create-and-use-unique-ptr-instances?view=msvc-170

A unique_ptr does not share its pointer. It cannot be copied to another unique_ptr, passed by value to a function, or used in any C++ Standard 
Library algorithm that requires copies to be made.
A unique_ptr can only be moved. This means that the ownership of the memory resource is transferred to another unique_ptr and the original 
unique_ptr no longer owns it.
unique_ptr is defined in the <memory> header in the C++ Standard Library. 
*****The addition of unique_ptr instances to C++ Standard Library containers is efficient because the move constructor of the unique_ptr eliminates 
the need for a copy operation.
unique_ptr copy constructor is deleted

As each unique_ptr object is sole owner of a raw pointer, therefore in its destructor it directly deletes the associated pointer.
There is no need of any reference counting, therefore its very light


***** example case issue*****

int main()
{
   int* p = new int;
   ..
   ...
   exception happens //fun return from here and deallocate local varibles.but heap memory not cleared. Wont delete p.//this is an issue
   
   delete p;
   return 0;
}

********  use of the unique ptr****************
#include<iostream>
using namespace std;
#include<memory>

class foo
{
private:
    int x;
    
public:
    foo(int a):x(a){
        
    }
    int getvalue(){return x;}
    ~foo()
    {
        cout<<"destroyed"<<endl;
    }
};

int main()
{
    foo *p = new foo(10);
    cout<<p->getvalue()<<endl;  //destructor not called. we forgot delete p
    
    std::unique_ptr<foo> spfoo(new foo(10));   //its an object on stack and when it goes out of scope its destructor is called 
    cout<<spfoo->getvalue()<<endl; //destructor called 
}

its a single ownership object.

/********* different ways to create the unique pointer*******
 std::unique_ptr<foo> spfoo(new foo(10));
 std::unique_ptr<foo> make_unique<foo>(10); ///best practice as its exception safe
 
 
 NOTE : 
 unique_ptr stores one pointer only. We can assign a different object by removing the current object from the pointer.
 
 ***** Creating a empty unique_ptr object
 std::unique_ptr<int> ptr1;
 
 // Create a unique_ptr object through raw pointer
std::unique_ptr<Task> taskPtr(new Task(23));

//NOTEEEEEEE
We can not create a unique_ptr<> object through assignment, otherwise it will cause compile error
// std::unique_ptr<Task> taskPtr2 = new Task(); // Compile Error


 
  





